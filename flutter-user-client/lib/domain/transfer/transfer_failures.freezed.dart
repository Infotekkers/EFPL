// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'transfer_failures.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$TransferFailureTearOff {
  const _$TransferFailureTearOff();

  NoTeamSelected<T> noTeamSelected<T>({required String failedValue}) {
    return NoTeamSelected<T>(
      failedValue: failedValue,
    );
  }

  ExceededPrice<T> exceededPrice<T>({required String failedValue}) {
    return ExceededPrice<T>(
      failedValue: failedValue,
    );
  }

  ExceededTeamCount<T> exceededTeamCount<T>({required String failedValue}) {
    return ExceededTeamCount<T>(
      failedValue: failedValue,
    );
  }

  IncompleteTeam<T> incompleteTeam<T>({required String failedValue}) {
    return IncompleteTeam<T>(
      failedValue: failedValue,
    );
  }

  DeadlinePassed<T> deadlinePassed<T>({required String failedValue}) {
    return DeadlinePassed<T>(
      failedValue: failedValue,
    );
  }

  Unauthenticated<T> unauthenticated<T>({required String failedValue}) {
    return Unauthenticated<T>(
      failedValue: failedValue,
    );
  }

  Unauthorized<T> unauthorized<T>({required String failedValue}) {
    return Unauthorized<T>(
      failedValue: failedValue,
    );
  }

  NoConnection<T> noConnection<T>({required String failedValue}) {
    return NoConnection<T>(
      failedValue: failedValue,
    );
  }

  SocketError<T> socketError<T>({required String failedValue}) {
    return SocketError<T>(
      failedValue: failedValue,
    );
  }

  HandShakeError<T> handShakeError<T>({required String failedValue}) {
    return HandShakeError<T>(
      failedValue: failedValue,
    );
  }

  UnexpectedError<T> unexpectedError<T>({required String failedValue}) {
    return UnexpectedError<T>(
      failedValue: failedValue,
    );
  }

  HiveError<T> hiveError<T>({required String failedValue}) {
    return HiveError<T>(
      failedValue: failedValue,
    );
  }

  SharedPreferencesError<T> sharedPreferencesError<T>(
      {required String failedValue}) {
    return SharedPreferencesError<T>(
      failedValue: failedValue,
    );
  }

  SecureStorageError<T> secureStorageError<T>({required String failedValue}) {
    return SecureStorageError<T>(
      failedValue: failedValue,
    );
  }
}

/// @nodoc
const $TransferFailure = _$TransferFailureTearOff();

/// @nodoc
mixin _$TransferFailure<T> {
  String get failedValue => throw _privateConstructorUsedError;

  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String failedValue) noTeamSelected,
    required TResult Function(String failedValue) exceededPrice,
    required TResult Function(String failedValue) exceededTeamCount,
    required TResult Function(String failedValue) incompleteTeam,
    required TResult Function(String failedValue) deadlinePassed,
    required TResult Function(String failedValue) unauthenticated,
    required TResult Function(String failedValue) unauthorized,
    required TResult Function(String failedValue) noConnection,
    required TResult Function(String failedValue) socketError,
    required TResult Function(String failedValue) handShakeError,
    required TResult Function(String failedValue) unexpectedError,
    required TResult Function(String failedValue) hiveError,
    required TResult Function(String failedValue) sharedPreferencesError,
    required TResult Function(String failedValue) secureStorageError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(String failedValue)? noTeamSelected,
    TResult Function(String failedValue)? exceededPrice,
    TResult Function(String failedValue)? exceededTeamCount,
    TResult Function(String failedValue)? incompleteTeam,
    TResult Function(String failedValue)? deadlinePassed,
    TResult Function(String failedValue)? unauthenticated,
    TResult Function(String failedValue)? unauthorized,
    TResult Function(String failedValue)? noConnection,
    TResult Function(String failedValue)? socketError,
    TResult Function(String failedValue)? handShakeError,
    TResult Function(String failedValue)? unexpectedError,
    TResult Function(String failedValue)? hiveError,
    TResult Function(String failedValue)? sharedPreferencesError,
    TResult Function(String failedValue)? secureStorageError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String failedValue)? noTeamSelected,
    TResult Function(String failedValue)? exceededPrice,
    TResult Function(String failedValue)? exceededTeamCount,
    TResult Function(String failedValue)? incompleteTeam,
    TResult Function(String failedValue)? deadlinePassed,
    TResult Function(String failedValue)? unauthenticated,
    TResult Function(String failedValue)? unauthorized,
    TResult Function(String failedValue)? noConnection,
    TResult Function(String failedValue)? socketError,
    TResult Function(String failedValue)? handShakeError,
    TResult Function(String failedValue)? unexpectedError,
    TResult Function(String failedValue)? hiveError,
    TResult Function(String failedValue)? sharedPreferencesError,
    TResult Function(String failedValue)? secureStorageError,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NoTeamSelected<T> value) noTeamSelected,
    required TResult Function(ExceededPrice<T> value) exceededPrice,
    required TResult Function(ExceededTeamCount<T> value) exceededTeamCount,
    required TResult Function(IncompleteTeam<T> value) incompleteTeam,
    required TResult Function(DeadlinePassed<T> value) deadlinePassed,
    required TResult Function(Unauthenticated<T> value) unauthenticated,
    required TResult Function(Unauthorized<T> value) unauthorized,
    required TResult Function(NoConnection<T> value) noConnection,
    required TResult Function(SocketError<T> value) socketError,
    required TResult Function(HandShakeError<T> value) handShakeError,
    required TResult Function(UnexpectedError<T> value) unexpectedError,
    required TResult Function(HiveError<T> value) hiveError,
    required TResult Function(SharedPreferencesError<T> value)
        sharedPreferencesError,
    required TResult Function(SecureStorageError<T> value) secureStorageError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(NoTeamSelected<T> value)? noTeamSelected,
    TResult Function(ExceededPrice<T> value)? exceededPrice,
    TResult Function(ExceededTeamCount<T> value)? exceededTeamCount,
    TResult Function(IncompleteTeam<T> value)? incompleteTeam,
    TResult Function(DeadlinePassed<T> value)? deadlinePassed,
    TResult Function(Unauthenticated<T> value)? unauthenticated,
    TResult Function(Unauthorized<T> value)? unauthorized,
    TResult Function(NoConnection<T> value)? noConnection,
    TResult Function(SocketError<T> value)? socketError,
    TResult Function(HandShakeError<T> value)? handShakeError,
    TResult Function(UnexpectedError<T> value)? unexpectedError,
    TResult Function(HiveError<T> value)? hiveError,
    TResult Function(SharedPreferencesError<T> value)? sharedPreferencesError,
    TResult Function(SecureStorageError<T> value)? secureStorageError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NoTeamSelected<T> value)? noTeamSelected,
    TResult Function(ExceededPrice<T> value)? exceededPrice,
    TResult Function(ExceededTeamCount<T> value)? exceededTeamCount,
    TResult Function(IncompleteTeam<T> value)? incompleteTeam,
    TResult Function(DeadlinePassed<T> value)? deadlinePassed,
    TResult Function(Unauthenticated<T> value)? unauthenticated,
    TResult Function(Unauthorized<T> value)? unauthorized,
    TResult Function(NoConnection<T> value)? noConnection,
    TResult Function(SocketError<T> value)? socketError,
    TResult Function(HandShakeError<T> value)? handShakeError,
    TResult Function(UnexpectedError<T> value)? unexpectedError,
    TResult Function(HiveError<T> value)? hiveError,
    TResult Function(SharedPreferencesError<T> value)? sharedPreferencesError,
    TResult Function(SecureStorageError<T> value)? secureStorageError,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $TransferFailureCopyWith<T, TransferFailure<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TransferFailureCopyWith<T, $Res> {
  factory $TransferFailureCopyWith(
          TransferFailure<T> value, $Res Function(TransferFailure<T>) then) =
      _$TransferFailureCopyWithImpl<T, $Res>;
  $Res call({String failedValue});
}

/// @nodoc
class _$TransferFailureCopyWithImpl<T, $Res>
    implements $TransferFailureCopyWith<T, $Res> {
  _$TransferFailureCopyWithImpl(this._value, this._then);

  final TransferFailure<T> _value;
  // ignore: unused_field
  final $Res Function(TransferFailure<T>) _then;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(_value.copyWith(
      failedValue: failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
abstract class $NoTeamSelectedCopyWith<T, $Res>
    implements $TransferFailureCopyWith<T, $Res> {
  factory $NoTeamSelectedCopyWith(
          NoTeamSelected<T> value, $Res Function(NoTeamSelected<T>) then) =
      _$NoTeamSelectedCopyWithImpl<T, $Res>;
  @override
  $Res call({String failedValue});
}

/// @nodoc
class _$NoTeamSelectedCopyWithImpl<T, $Res>
    extends _$TransferFailureCopyWithImpl<T, $Res>
    implements $NoTeamSelectedCopyWith<T, $Res> {
  _$NoTeamSelectedCopyWithImpl(
      NoTeamSelected<T> _value, $Res Function(NoTeamSelected<T>) _then)
      : super(_value, (v) => _then(v as NoTeamSelected<T>));

  @override
  NoTeamSelected<T> get _value => super._value as NoTeamSelected<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(NoTeamSelected<T>(
      failedValue: failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$NoTeamSelected<T> implements NoTeamSelected<T> {
  const _$NoTeamSelected({required this.failedValue});

  @override
  final String failedValue;

  @override
  String toString() {
    return 'TransferFailure<$T>.noTeamSelected(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is NoTeamSelected<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  @JsonKey(ignore: true)
  @override
  $NoTeamSelectedCopyWith<T, NoTeamSelected<T>> get copyWith =>
      _$NoTeamSelectedCopyWithImpl<T, NoTeamSelected<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String failedValue) noTeamSelected,
    required TResult Function(String failedValue) exceededPrice,
    required TResult Function(String failedValue) exceededTeamCount,
    required TResult Function(String failedValue) incompleteTeam,
    required TResult Function(String failedValue) deadlinePassed,
    required TResult Function(String failedValue) unauthenticated,
    required TResult Function(String failedValue) unauthorized,
    required TResult Function(String failedValue) noConnection,
    required TResult Function(String failedValue) socketError,
    required TResult Function(String failedValue) handShakeError,
    required TResult Function(String failedValue) unexpectedError,
    required TResult Function(String failedValue) hiveError,
    required TResult Function(String failedValue) sharedPreferencesError,
    required TResult Function(String failedValue) secureStorageError,
  }) {
    return noTeamSelected(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(String failedValue)? noTeamSelected,
    TResult Function(String failedValue)? exceededPrice,
    TResult Function(String failedValue)? exceededTeamCount,
    TResult Function(String failedValue)? incompleteTeam,
    TResult Function(String failedValue)? deadlinePassed,
    TResult Function(String failedValue)? unauthenticated,
    TResult Function(String failedValue)? unauthorized,
    TResult Function(String failedValue)? noConnection,
    TResult Function(String failedValue)? socketError,
    TResult Function(String failedValue)? handShakeError,
    TResult Function(String failedValue)? unexpectedError,
    TResult Function(String failedValue)? hiveError,
    TResult Function(String failedValue)? sharedPreferencesError,
    TResult Function(String failedValue)? secureStorageError,
  }) {
    return noTeamSelected?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String failedValue)? noTeamSelected,
    TResult Function(String failedValue)? exceededPrice,
    TResult Function(String failedValue)? exceededTeamCount,
    TResult Function(String failedValue)? incompleteTeam,
    TResult Function(String failedValue)? deadlinePassed,
    TResult Function(String failedValue)? unauthenticated,
    TResult Function(String failedValue)? unauthorized,
    TResult Function(String failedValue)? noConnection,
    TResult Function(String failedValue)? socketError,
    TResult Function(String failedValue)? handShakeError,
    TResult Function(String failedValue)? unexpectedError,
    TResult Function(String failedValue)? hiveError,
    TResult Function(String failedValue)? sharedPreferencesError,
    TResult Function(String failedValue)? secureStorageError,
    required TResult orElse(),
  }) {
    if (noTeamSelected != null) {
      return noTeamSelected(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NoTeamSelected<T> value) noTeamSelected,
    required TResult Function(ExceededPrice<T> value) exceededPrice,
    required TResult Function(ExceededTeamCount<T> value) exceededTeamCount,
    required TResult Function(IncompleteTeam<T> value) incompleteTeam,
    required TResult Function(DeadlinePassed<T> value) deadlinePassed,
    required TResult Function(Unauthenticated<T> value) unauthenticated,
    required TResult Function(Unauthorized<T> value) unauthorized,
    required TResult Function(NoConnection<T> value) noConnection,
    required TResult Function(SocketError<T> value) socketError,
    required TResult Function(HandShakeError<T> value) handShakeError,
    required TResult Function(UnexpectedError<T> value) unexpectedError,
    required TResult Function(HiveError<T> value) hiveError,
    required TResult Function(SharedPreferencesError<T> value)
        sharedPreferencesError,
    required TResult Function(SecureStorageError<T> value) secureStorageError,
  }) {
    return noTeamSelected(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(NoTeamSelected<T> value)? noTeamSelected,
    TResult Function(ExceededPrice<T> value)? exceededPrice,
    TResult Function(ExceededTeamCount<T> value)? exceededTeamCount,
    TResult Function(IncompleteTeam<T> value)? incompleteTeam,
    TResult Function(DeadlinePassed<T> value)? deadlinePassed,
    TResult Function(Unauthenticated<T> value)? unauthenticated,
    TResult Function(Unauthorized<T> value)? unauthorized,
    TResult Function(NoConnection<T> value)? noConnection,
    TResult Function(SocketError<T> value)? socketError,
    TResult Function(HandShakeError<T> value)? handShakeError,
    TResult Function(UnexpectedError<T> value)? unexpectedError,
    TResult Function(HiveError<T> value)? hiveError,
    TResult Function(SharedPreferencesError<T> value)? sharedPreferencesError,
    TResult Function(SecureStorageError<T> value)? secureStorageError,
  }) {
    return noTeamSelected?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NoTeamSelected<T> value)? noTeamSelected,
    TResult Function(ExceededPrice<T> value)? exceededPrice,
    TResult Function(ExceededTeamCount<T> value)? exceededTeamCount,
    TResult Function(IncompleteTeam<T> value)? incompleteTeam,
    TResult Function(DeadlinePassed<T> value)? deadlinePassed,
    TResult Function(Unauthenticated<T> value)? unauthenticated,
    TResult Function(Unauthorized<T> value)? unauthorized,
    TResult Function(NoConnection<T> value)? noConnection,
    TResult Function(SocketError<T> value)? socketError,
    TResult Function(HandShakeError<T> value)? handShakeError,
    TResult Function(UnexpectedError<T> value)? unexpectedError,
    TResult Function(HiveError<T> value)? hiveError,
    TResult Function(SharedPreferencesError<T> value)? sharedPreferencesError,
    TResult Function(SecureStorageError<T> value)? secureStorageError,
    required TResult orElse(),
  }) {
    if (noTeamSelected != null) {
      return noTeamSelected(this);
    }
    return orElse();
  }
}

abstract class NoTeamSelected<T> implements TransferFailure<T> {
  const factory NoTeamSelected({required String failedValue}) =
      _$NoTeamSelected<T>;

  @override
  String get failedValue;
  @override
  @JsonKey(ignore: true)
  $NoTeamSelectedCopyWith<T, NoTeamSelected<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ExceededPriceCopyWith<T, $Res>
    implements $TransferFailureCopyWith<T, $Res> {
  factory $ExceededPriceCopyWith(
          ExceededPrice<T> value, $Res Function(ExceededPrice<T>) then) =
      _$ExceededPriceCopyWithImpl<T, $Res>;
  @override
  $Res call({String failedValue});
}

/// @nodoc
class _$ExceededPriceCopyWithImpl<T, $Res>
    extends _$TransferFailureCopyWithImpl<T, $Res>
    implements $ExceededPriceCopyWith<T, $Res> {
  _$ExceededPriceCopyWithImpl(
      ExceededPrice<T> _value, $Res Function(ExceededPrice<T>) _then)
      : super(_value, (v) => _then(v as ExceededPrice<T>));

  @override
  ExceededPrice<T> get _value => super._value as ExceededPrice<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(ExceededPrice<T>(
      failedValue: failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$ExceededPrice<T> implements ExceededPrice<T> {
  const _$ExceededPrice({required this.failedValue});

  @override
  final String failedValue;

  @override
  String toString() {
    return 'TransferFailure<$T>.exceededPrice(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ExceededPrice<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  @JsonKey(ignore: true)
  @override
  $ExceededPriceCopyWith<T, ExceededPrice<T>> get copyWith =>
      _$ExceededPriceCopyWithImpl<T, ExceededPrice<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String failedValue) noTeamSelected,
    required TResult Function(String failedValue) exceededPrice,
    required TResult Function(String failedValue) exceededTeamCount,
    required TResult Function(String failedValue) incompleteTeam,
    required TResult Function(String failedValue) deadlinePassed,
    required TResult Function(String failedValue) unauthenticated,
    required TResult Function(String failedValue) unauthorized,
    required TResult Function(String failedValue) noConnection,
    required TResult Function(String failedValue) socketError,
    required TResult Function(String failedValue) handShakeError,
    required TResult Function(String failedValue) unexpectedError,
    required TResult Function(String failedValue) hiveError,
    required TResult Function(String failedValue) sharedPreferencesError,
    required TResult Function(String failedValue) secureStorageError,
  }) {
    return exceededPrice(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(String failedValue)? noTeamSelected,
    TResult Function(String failedValue)? exceededPrice,
    TResult Function(String failedValue)? exceededTeamCount,
    TResult Function(String failedValue)? incompleteTeam,
    TResult Function(String failedValue)? deadlinePassed,
    TResult Function(String failedValue)? unauthenticated,
    TResult Function(String failedValue)? unauthorized,
    TResult Function(String failedValue)? noConnection,
    TResult Function(String failedValue)? socketError,
    TResult Function(String failedValue)? handShakeError,
    TResult Function(String failedValue)? unexpectedError,
    TResult Function(String failedValue)? hiveError,
    TResult Function(String failedValue)? sharedPreferencesError,
    TResult Function(String failedValue)? secureStorageError,
  }) {
    return exceededPrice?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String failedValue)? noTeamSelected,
    TResult Function(String failedValue)? exceededPrice,
    TResult Function(String failedValue)? exceededTeamCount,
    TResult Function(String failedValue)? incompleteTeam,
    TResult Function(String failedValue)? deadlinePassed,
    TResult Function(String failedValue)? unauthenticated,
    TResult Function(String failedValue)? unauthorized,
    TResult Function(String failedValue)? noConnection,
    TResult Function(String failedValue)? socketError,
    TResult Function(String failedValue)? handShakeError,
    TResult Function(String failedValue)? unexpectedError,
    TResult Function(String failedValue)? hiveError,
    TResult Function(String failedValue)? sharedPreferencesError,
    TResult Function(String failedValue)? secureStorageError,
    required TResult orElse(),
  }) {
    if (exceededPrice != null) {
      return exceededPrice(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NoTeamSelected<T> value) noTeamSelected,
    required TResult Function(ExceededPrice<T> value) exceededPrice,
    required TResult Function(ExceededTeamCount<T> value) exceededTeamCount,
    required TResult Function(IncompleteTeam<T> value) incompleteTeam,
    required TResult Function(DeadlinePassed<T> value) deadlinePassed,
    required TResult Function(Unauthenticated<T> value) unauthenticated,
    required TResult Function(Unauthorized<T> value) unauthorized,
    required TResult Function(NoConnection<T> value) noConnection,
    required TResult Function(SocketError<T> value) socketError,
    required TResult Function(HandShakeError<T> value) handShakeError,
    required TResult Function(UnexpectedError<T> value) unexpectedError,
    required TResult Function(HiveError<T> value) hiveError,
    required TResult Function(SharedPreferencesError<T> value)
        sharedPreferencesError,
    required TResult Function(SecureStorageError<T> value) secureStorageError,
  }) {
    return exceededPrice(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(NoTeamSelected<T> value)? noTeamSelected,
    TResult Function(ExceededPrice<T> value)? exceededPrice,
    TResult Function(ExceededTeamCount<T> value)? exceededTeamCount,
    TResult Function(IncompleteTeam<T> value)? incompleteTeam,
    TResult Function(DeadlinePassed<T> value)? deadlinePassed,
    TResult Function(Unauthenticated<T> value)? unauthenticated,
    TResult Function(Unauthorized<T> value)? unauthorized,
    TResult Function(NoConnection<T> value)? noConnection,
    TResult Function(SocketError<T> value)? socketError,
    TResult Function(HandShakeError<T> value)? handShakeError,
    TResult Function(UnexpectedError<T> value)? unexpectedError,
    TResult Function(HiveError<T> value)? hiveError,
    TResult Function(SharedPreferencesError<T> value)? sharedPreferencesError,
    TResult Function(SecureStorageError<T> value)? secureStorageError,
  }) {
    return exceededPrice?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NoTeamSelected<T> value)? noTeamSelected,
    TResult Function(ExceededPrice<T> value)? exceededPrice,
    TResult Function(ExceededTeamCount<T> value)? exceededTeamCount,
    TResult Function(IncompleteTeam<T> value)? incompleteTeam,
    TResult Function(DeadlinePassed<T> value)? deadlinePassed,
    TResult Function(Unauthenticated<T> value)? unauthenticated,
    TResult Function(Unauthorized<T> value)? unauthorized,
    TResult Function(NoConnection<T> value)? noConnection,
    TResult Function(SocketError<T> value)? socketError,
    TResult Function(HandShakeError<T> value)? handShakeError,
    TResult Function(UnexpectedError<T> value)? unexpectedError,
    TResult Function(HiveError<T> value)? hiveError,
    TResult Function(SharedPreferencesError<T> value)? sharedPreferencesError,
    TResult Function(SecureStorageError<T> value)? secureStorageError,
    required TResult orElse(),
  }) {
    if (exceededPrice != null) {
      return exceededPrice(this);
    }
    return orElse();
  }
}

abstract class ExceededPrice<T> implements TransferFailure<T> {
  const factory ExceededPrice({required String failedValue}) =
      _$ExceededPrice<T>;

  @override
  String get failedValue;
  @override
  @JsonKey(ignore: true)
  $ExceededPriceCopyWith<T, ExceededPrice<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ExceededTeamCountCopyWith<T, $Res>
    implements $TransferFailureCopyWith<T, $Res> {
  factory $ExceededTeamCountCopyWith(ExceededTeamCount<T> value,
          $Res Function(ExceededTeamCount<T>) then) =
      _$ExceededTeamCountCopyWithImpl<T, $Res>;
  @override
  $Res call({String failedValue});
}

/// @nodoc
class _$ExceededTeamCountCopyWithImpl<T, $Res>
    extends _$TransferFailureCopyWithImpl<T, $Res>
    implements $ExceededTeamCountCopyWith<T, $Res> {
  _$ExceededTeamCountCopyWithImpl(
      ExceededTeamCount<T> _value, $Res Function(ExceededTeamCount<T>) _then)
      : super(_value, (v) => _then(v as ExceededTeamCount<T>));

  @override
  ExceededTeamCount<T> get _value => super._value as ExceededTeamCount<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(ExceededTeamCount<T>(
      failedValue: failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$ExceededTeamCount<T> implements ExceededTeamCount<T> {
  const _$ExceededTeamCount({required this.failedValue});

  @override
  final String failedValue;

  @override
  String toString() {
    return 'TransferFailure<$T>.exceededTeamCount(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ExceededTeamCount<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  @JsonKey(ignore: true)
  @override
  $ExceededTeamCountCopyWith<T, ExceededTeamCount<T>> get copyWith =>
      _$ExceededTeamCountCopyWithImpl<T, ExceededTeamCount<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String failedValue) noTeamSelected,
    required TResult Function(String failedValue) exceededPrice,
    required TResult Function(String failedValue) exceededTeamCount,
    required TResult Function(String failedValue) incompleteTeam,
    required TResult Function(String failedValue) deadlinePassed,
    required TResult Function(String failedValue) unauthenticated,
    required TResult Function(String failedValue) unauthorized,
    required TResult Function(String failedValue) noConnection,
    required TResult Function(String failedValue) socketError,
    required TResult Function(String failedValue) handShakeError,
    required TResult Function(String failedValue) unexpectedError,
    required TResult Function(String failedValue) hiveError,
    required TResult Function(String failedValue) sharedPreferencesError,
    required TResult Function(String failedValue) secureStorageError,
  }) {
    return exceededTeamCount(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(String failedValue)? noTeamSelected,
    TResult Function(String failedValue)? exceededPrice,
    TResult Function(String failedValue)? exceededTeamCount,
    TResult Function(String failedValue)? incompleteTeam,
    TResult Function(String failedValue)? deadlinePassed,
    TResult Function(String failedValue)? unauthenticated,
    TResult Function(String failedValue)? unauthorized,
    TResult Function(String failedValue)? noConnection,
    TResult Function(String failedValue)? socketError,
    TResult Function(String failedValue)? handShakeError,
    TResult Function(String failedValue)? unexpectedError,
    TResult Function(String failedValue)? hiveError,
    TResult Function(String failedValue)? sharedPreferencesError,
    TResult Function(String failedValue)? secureStorageError,
  }) {
    return exceededTeamCount?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String failedValue)? noTeamSelected,
    TResult Function(String failedValue)? exceededPrice,
    TResult Function(String failedValue)? exceededTeamCount,
    TResult Function(String failedValue)? incompleteTeam,
    TResult Function(String failedValue)? deadlinePassed,
    TResult Function(String failedValue)? unauthenticated,
    TResult Function(String failedValue)? unauthorized,
    TResult Function(String failedValue)? noConnection,
    TResult Function(String failedValue)? socketError,
    TResult Function(String failedValue)? handShakeError,
    TResult Function(String failedValue)? unexpectedError,
    TResult Function(String failedValue)? hiveError,
    TResult Function(String failedValue)? sharedPreferencesError,
    TResult Function(String failedValue)? secureStorageError,
    required TResult orElse(),
  }) {
    if (exceededTeamCount != null) {
      return exceededTeamCount(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NoTeamSelected<T> value) noTeamSelected,
    required TResult Function(ExceededPrice<T> value) exceededPrice,
    required TResult Function(ExceededTeamCount<T> value) exceededTeamCount,
    required TResult Function(IncompleteTeam<T> value) incompleteTeam,
    required TResult Function(DeadlinePassed<T> value) deadlinePassed,
    required TResult Function(Unauthenticated<T> value) unauthenticated,
    required TResult Function(Unauthorized<T> value) unauthorized,
    required TResult Function(NoConnection<T> value) noConnection,
    required TResult Function(SocketError<T> value) socketError,
    required TResult Function(HandShakeError<T> value) handShakeError,
    required TResult Function(UnexpectedError<T> value) unexpectedError,
    required TResult Function(HiveError<T> value) hiveError,
    required TResult Function(SharedPreferencesError<T> value)
        sharedPreferencesError,
    required TResult Function(SecureStorageError<T> value) secureStorageError,
  }) {
    return exceededTeamCount(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(NoTeamSelected<T> value)? noTeamSelected,
    TResult Function(ExceededPrice<T> value)? exceededPrice,
    TResult Function(ExceededTeamCount<T> value)? exceededTeamCount,
    TResult Function(IncompleteTeam<T> value)? incompleteTeam,
    TResult Function(DeadlinePassed<T> value)? deadlinePassed,
    TResult Function(Unauthenticated<T> value)? unauthenticated,
    TResult Function(Unauthorized<T> value)? unauthorized,
    TResult Function(NoConnection<T> value)? noConnection,
    TResult Function(SocketError<T> value)? socketError,
    TResult Function(HandShakeError<T> value)? handShakeError,
    TResult Function(UnexpectedError<T> value)? unexpectedError,
    TResult Function(HiveError<T> value)? hiveError,
    TResult Function(SharedPreferencesError<T> value)? sharedPreferencesError,
    TResult Function(SecureStorageError<T> value)? secureStorageError,
  }) {
    return exceededTeamCount?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NoTeamSelected<T> value)? noTeamSelected,
    TResult Function(ExceededPrice<T> value)? exceededPrice,
    TResult Function(ExceededTeamCount<T> value)? exceededTeamCount,
    TResult Function(IncompleteTeam<T> value)? incompleteTeam,
    TResult Function(DeadlinePassed<T> value)? deadlinePassed,
    TResult Function(Unauthenticated<T> value)? unauthenticated,
    TResult Function(Unauthorized<T> value)? unauthorized,
    TResult Function(NoConnection<T> value)? noConnection,
    TResult Function(SocketError<T> value)? socketError,
    TResult Function(HandShakeError<T> value)? handShakeError,
    TResult Function(UnexpectedError<T> value)? unexpectedError,
    TResult Function(HiveError<T> value)? hiveError,
    TResult Function(SharedPreferencesError<T> value)? sharedPreferencesError,
    TResult Function(SecureStorageError<T> value)? secureStorageError,
    required TResult orElse(),
  }) {
    if (exceededTeamCount != null) {
      return exceededTeamCount(this);
    }
    return orElse();
  }
}

abstract class ExceededTeamCount<T> implements TransferFailure<T> {
  const factory ExceededTeamCount({required String failedValue}) =
      _$ExceededTeamCount<T>;

  @override
  String get failedValue;
  @override
  @JsonKey(ignore: true)
  $ExceededTeamCountCopyWith<T, ExceededTeamCount<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $IncompleteTeamCopyWith<T, $Res>
    implements $TransferFailureCopyWith<T, $Res> {
  factory $IncompleteTeamCopyWith(
          IncompleteTeam<T> value, $Res Function(IncompleteTeam<T>) then) =
      _$IncompleteTeamCopyWithImpl<T, $Res>;
  @override
  $Res call({String failedValue});
}

/// @nodoc
class _$IncompleteTeamCopyWithImpl<T, $Res>
    extends _$TransferFailureCopyWithImpl<T, $Res>
    implements $IncompleteTeamCopyWith<T, $Res> {
  _$IncompleteTeamCopyWithImpl(
      IncompleteTeam<T> _value, $Res Function(IncompleteTeam<T>) _then)
      : super(_value, (v) => _then(v as IncompleteTeam<T>));

  @override
  IncompleteTeam<T> get _value => super._value as IncompleteTeam<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(IncompleteTeam<T>(
      failedValue: failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$IncompleteTeam<T> implements IncompleteTeam<T> {
  const _$IncompleteTeam({required this.failedValue});

  @override
  final String failedValue;

  @override
  String toString() {
    return 'TransferFailure<$T>.incompleteTeam(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is IncompleteTeam<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  @JsonKey(ignore: true)
  @override
  $IncompleteTeamCopyWith<T, IncompleteTeam<T>> get copyWith =>
      _$IncompleteTeamCopyWithImpl<T, IncompleteTeam<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String failedValue) noTeamSelected,
    required TResult Function(String failedValue) exceededPrice,
    required TResult Function(String failedValue) exceededTeamCount,
    required TResult Function(String failedValue) incompleteTeam,
    required TResult Function(String failedValue) deadlinePassed,
    required TResult Function(String failedValue) unauthenticated,
    required TResult Function(String failedValue) unauthorized,
    required TResult Function(String failedValue) noConnection,
    required TResult Function(String failedValue) socketError,
    required TResult Function(String failedValue) handShakeError,
    required TResult Function(String failedValue) unexpectedError,
    required TResult Function(String failedValue) hiveError,
    required TResult Function(String failedValue) sharedPreferencesError,
    required TResult Function(String failedValue) secureStorageError,
  }) {
    return incompleteTeam(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(String failedValue)? noTeamSelected,
    TResult Function(String failedValue)? exceededPrice,
    TResult Function(String failedValue)? exceededTeamCount,
    TResult Function(String failedValue)? incompleteTeam,
    TResult Function(String failedValue)? deadlinePassed,
    TResult Function(String failedValue)? unauthenticated,
    TResult Function(String failedValue)? unauthorized,
    TResult Function(String failedValue)? noConnection,
    TResult Function(String failedValue)? socketError,
    TResult Function(String failedValue)? handShakeError,
    TResult Function(String failedValue)? unexpectedError,
    TResult Function(String failedValue)? hiveError,
    TResult Function(String failedValue)? sharedPreferencesError,
    TResult Function(String failedValue)? secureStorageError,
  }) {
    return incompleteTeam?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String failedValue)? noTeamSelected,
    TResult Function(String failedValue)? exceededPrice,
    TResult Function(String failedValue)? exceededTeamCount,
    TResult Function(String failedValue)? incompleteTeam,
    TResult Function(String failedValue)? deadlinePassed,
    TResult Function(String failedValue)? unauthenticated,
    TResult Function(String failedValue)? unauthorized,
    TResult Function(String failedValue)? noConnection,
    TResult Function(String failedValue)? socketError,
    TResult Function(String failedValue)? handShakeError,
    TResult Function(String failedValue)? unexpectedError,
    TResult Function(String failedValue)? hiveError,
    TResult Function(String failedValue)? sharedPreferencesError,
    TResult Function(String failedValue)? secureStorageError,
    required TResult orElse(),
  }) {
    if (incompleteTeam != null) {
      return incompleteTeam(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NoTeamSelected<T> value) noTeamSelected,
    required TResult Function(ExceededPrice<T> value) exceededPrice,
    required TResult Function(ExceededTeamCount<T> value) exceededTeamCount,
    required TResult Function(IncompleteTeam<T> value) incompleteTeam,
    required TResult Function(DeadlinePassed<T> value) deadlinePassed,
    required TResult Function(Unauthenticated<T> value) unauthenticated,
    required TResult Function(Unauthorized<T> value) unauthorized,
    required TResult Function(NoConnection<T> value) noConnection,
    required TResult Function(SocketError<T> value) socketError,
    required TResult Function(HandShakeError<T> value) handShakeError,
    required TResult Function(UnexpectedError<T> value) unexpectedError,
    required TResult Function(HiveError<T> value) hiveError,
    required TResult Function(SharedPreferencesError<T> value)
        sharedPreferencesError,
    required TResult Function(SecureStorageError<T> value) secureStorageError,
  }) {
    return incompleteTeam(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(NoTeamSelected<T> value)? noTeamSelected,
    TResult Function(ExceededPrice<T> value)? exceededPrice,
    TResult Function(ExceededTeamCount<T> value)? exceededTeamCount,
    TResult Function(IncompleteTeam<T> value)? incompleteTeam,
    TResult Function(DeadlinePassed<T> value)? deadlinePassed,
    TResult Function(Unauthenticated<T> value)? unauthenticated,
    TResult Function(Unauthorized<T> value)? unauthorized,
    TResult Function(NoConnection<T> value)? noConnection,
    TResult Function(SocketError<T> value)? socketError,
    TResult Function(HandShakeError<T> value)? handShakeError,
    TResult Function(UnexpectedError<T> value)? unexpectedError,
    TResult Function(HiveError<T> value)? hiveError,
    TResult Function(SharedPreferencesError<T> value)? sharedPreferencesError,
    TResult Function(SecureStorageError<T> value)? secureStorageError,
  }) {
    return incompleteTeam?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NoTeamSelected<T> value)? noTeamSelected,
    TResult Function(ExceededPrice<T> value)? exceededPrice,
    TResult Function(ExceededTeamCount<T> value)? exceededTeamCount,
    TResult Function(IncompleteTeam<T> value)? incompleteTeam,
    TResult Function(DeadlinePassed<T> value)? deadlinePassed,
    TResult Function(Unauthenticated<T> value)? unauthenticated,
    TResult Function(Unauthorized<T> value)? unauthorized,
    TResult Function(NoConnection<T> value)? noConnection,
    TResult Function(SocketError<T> value)? socketError,
    TResult Function(HandShakeError<T> value)? handShakeError,
    TResult Function(UnexpectedError<T> value)? unexpectedError,
    TResult Function(HiveError<T> value)? hiveError,
    TResult Function(SharedPreferencesError<T> value)? sharedPreferencesError,
    TResult Function(SecureStorageError<T> value)? secureStorageError,
    required TResult orElse(),
  }) {
    if (incompleteTeam != null) {
      return incompleteTeam(this);
    }
    return orElse();
  }
}

abstract class IncompleteTeam<T> implements TransferFailure<T> {
  const factory IncompleteTeam({required String failedValue}) =
      _$IncompleteTeam<T>;

  @override
  String get failedValue;
  @override
  @JsonKey(ignore: true)
  $IncompleteTeamCopyWith<T, IncompleteTeam<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DeadlinePassedCopyWith<T, $Res>
    implements $TransferFailureCopyWith<T, $Res> {
  factory $DeadlinePassedCopyWith(
          DeadlinePassed<T> value, $Res Function(DeadlinePassed<T>) then) =
      _$DeadlinePassedCopyWithImpl<T, $Res>;
  @override
  $Res call({String failedValue});
}

/// @nodoc
class _$DeadlinePassedCopyWithImpl<T, $Res>
    extends _$TransferFailureCopyWithImpl<T, $Res>
    implements $DeadlinePassedCopyWith<T, $Res> {
  _$DeadlinePassedCopyWithImpl(
      DeadlinePassed<T> _value, $Res Function(DeadlinePassed<T>) _then)
      : super(_value, (v) => _then(v as DeadlinePassed<T>));

  @override
  DeadlinePassed<T> get _value => super._value as DeadlinePassed<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(DeadlinePassed<T>(
      failedValue: failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$DeadlinePassed<T> implements DeadlinePassed<T> {
  const _$DeadlinePassed({required this.failedValue});

  @override
  final String failedValue;

  @override
  String toString() {
    return 'TransferFailure<$T>.deadlinePassed(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is DeadlinePassed<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  @JsonKey(ignore: true)
  @override
  $DeadlinePassedCopyWith<T, DeadlinePassed<T>> get copyWith =>
      _$DeadlinePassedCopyWithImpl<T, DeadlinePassed<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String failedValue) noTeamSelected,
    required TResult Function(String failedValue) exceededPrice,
    required TResult Function(String failedValue) exceededTeamCount,
    required TResult Function(String failedValue) incompleteTeam,
    required TResult Function(String failedValue) deadlinePassed,
    required TResult Function(String failedValue) unauthenticated,
    required TResult Function(String failedValue) unauthorized,
    required TResult Function(String failedValue) noConnection,
    required TResult Function(String failedValue) socketError,
    required TResult Function(String failedValue) handShakeError,
    required TResult Function(String failedValue) unexpectedError,
    required TResult Function(String failedValue) hiveError,
    required TResult Function(String failedValue) sharedPreferencesError,
    required TResult Function(String failedValue) secureStorageError,
  }) {
    return deadlinePassed(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(String failedValue)? noTeamSelected,
    TResult Function(String failedValue)? exceededPrice,
    TResult Function(String failedValue)? exceededTeamCount,
    TResult Function(String failedValue)? incompleteTeam,
    TResult Function(String failedValue)? deadlinePassed,
    TResult Function(String failedValue)? unauthenticated,
    TResult Function(String failedValue)? unauthorized,
    TResult Function(String failedValue)? noConnection,
    TResult Function(String failedValue)? socketError,
    TResult Function(String failedValue)? handShakeError,
    TResult Function(String failedValue)? unexpectedError,
    TResult Function(String failedValue)? hiveError,
    TResult Function(String failedValue)? sharedPreferencesError,
    TResult Function(String failedValue)? secureStorageError,
  }) {
    return deadlinePassed?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String failedValue)? noTeamSelected,
    TResult Function(String failedValue)? exceededPrice,
    TResult Function(String failedValue)? exceededTeamCount,
    TResult Function(String failedValue)? incompleteTeam,
    TResult Function(String failedValue)? deadlinePassed,
    TResult Function(String failedValue)? unauthenticated,
    TResult Function(String failedValue)? unauthorized,
    TResult Function(String failedValue)? noConnection,
    TResult Function(String failedValue)? socketError,
    TResult Function(String failedValue)? handShakeError,
    TResult Function(String failedValue)? unexpectedError,
    TResult Function(String failedValue)? hiveError,
    TResult Function(String failedValue)? sharedPreferencesError,
    TResult Function(String failedValue)? secureStorageError,
    required TResult orElse(),
  }) {
    if (deadlinePassed != null) {
      return deadlinePassed(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NoTeamSelected<T> value) noTeamSelected,
    required TResult Function(ExceededPrice<T> value) exceededPrice,
    required TResult Function(ExceededTeamCount<T> value) exceededTeamCount,
    required TResult Function(IncompleteTeam<T> value) incompleteTeam,
    required TResult Function(DeadlinePassed<T> value) deadlinePassed,
    required TResult Function(Unauthenticated<T> value) unauthenticated,
    required TResult Function(Unauthorized<T> value) unauthorized,
    required TResult Function(NoConnection<T> value) noConnection,
    required TResult Function(SocketError<T> value) socketError,
    required TResult Function(HandShakeError<T> value) handShakeError,
    required TResult Function(UnexpectedError<T> value) unexpectedError,
    required TResult Function(HiveError<T> value) hiveError,
    required TResult Function(SharedPreferencesError<T> value)
        sharedPreferencesError,
    required TResult Function(SecureStorageError<T> value) secureStorageError,
  }) {
    return deadlinePassed(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(NoTeamSelected<T> value)? noTeamSelected,
    TResult Function(ExceededPrice<T> value)? exceededPrice,
    TResult Function(ExceededTeamCount<T> value)? exceededTeamCount,
    TResult Function(IncompleteTeam<T> value)? incompleteTeam,
    TResult Function(DeadlinePassed<T> value)? deadlinePassed,
    TResult Function(Unauthenticated<T> value)? unauthenticated,
    TResult Function(Unauthorized<T> value)? unauthorized,
    TResult Function(NoConnection<T> value)? noConnection,
    TResult Function(SocketError<T> value)? socketError,
    TResult Function(HandShakeError<T> value)? handShakeError,
    TResult Function(UnexpectedError<T> value)? unexpectedError,
    TResult Function(HiveError<T> value)? hiveError,
    TResult Function(SharedPreferencesError<T> value)? sharedPreferencesError,
    TResult Function(SecureStorageError<T> value)? secureStorageError,
  }) {
    return deadlinePassed?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NoTeamSelected<T> value)? noTeamSelected,
    TResult Function(ExceededPrice<T> value)? exceededPrice,
    TResult Function(ExceededTeamCount<T> value)? exceededTeamCount,
    TResult Function(IncompleteTeam<T> value)? incompleteTeam,
    TResult Function(DeadlinePassed<T> value)? deadlinePassed,
    TResult Function(Unauthenticated<T> value)? unauthenticated,
    TResult Function(Unauthorized<T> value)? unauthorized,
    TResult Function(NoConnection<T> value)? noConnection,
    TResult Function(SocketError<T> value)? socketError,
    TResult Function(HandShakeError<T> value)? handShakeError,
    TResult Function(UnexpectedError<T> value)? unexpectedError,
    TResult Function(HiveError<T> value)? hiveError,
    TResult Function(SharedPreferencesError<T> value)? sharedPreferencesError,
    TResult Function(SecureStorageError<T> value)? secureStorageError,
    required TResult orElse(),
  }) {
    if (deadlinePassed != null) {
      return deadlinePassed(this);
    }
    return orElse();
  }
}

abstract class DeadlinePassed<T> implements TransferFailure<T> {
  const factory DeadlinePassed({required String failedValue}) =
      _$DeadlinePassed<T>;

  @override
  String get failedValue;
  @override
  @JsonKey(ignore: true)
  $DeadlinePassedCopyWith<T, DeadlinePassed<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UnauthenticatedCopyWith<T, $Res>
    implements $TransferFailureCopyWith<T, $Res> {
  factory $UnauthenticatedCopyWith(
          Unauthenticated<T> value, $Res Function(Unauthenticated<T>) then) =
      _$UnauthenticatedCopyWithImpl<T, $Res>;
  @override
  $Res call({String failedValue});
}

/// @nodoc
class _$UnauthenticatedCopyWithImpl<T, $Res>
    extends _$TransferFailureCopyWithImpl<T, $Res>
    implements $UnauthenticatedCopyWith<T, $Res> {
  _$UnauthenticatedCopyWithImpl(
      Unauthenticated<T> _value, $Res Function(Unauthenticated<T>) _then)
      : super(_value, (v) => _then(v as Unauthenticated<T>));

  @override
  Unauthenticated<T> get _value => super._value as Unauthenticated<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(Unauthenticated<T>(
      failedValue: failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$Unauthenticated<T> implements Unauthenticated<T> {
  const _$Unauthenticated({required this.failedValue});

  @override
  final String failedValue;

  @override
  String toString() {
    return 'TransferFailure<$T>.unauthenticated(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is Unauthenticated<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  @JsonKey(ignore: true)
  @override
  $UnauthenticatedCopyWith<T, Unauthenticated<T>> get copyWith =>
      _$UnauthenticatedCopyWithImpl<T, Unauthenticated<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String failedValue) noTeamSelected,
    required TResult Function(String failedValue) exceededPrice,
    required TResult Function(String failedValue) exceededTeamCount,
    required TResult Function(String failedValue) incompleteTeam,
    required TResult Function(String failedValue) deadlinePassed,
    required TResult Function(String failedValue) unauthenticated,
    required TResult Function(String failedValue) unauthorized,
    required TResult Function(String failedValue) noConnection,
    required TResult Function(String failedValue) socketError,
    required TResult Function(String failedValue) handShakeError,
    required TResult Function(String failedValue) unexpectedError,
    required TResult Function(String failedValue) hiveError,
    required TResult Function(String failedValue) sharedPreferencesError,
    required TResult Function(String failedValue) secureStorageError,
  }) {
    return unauthenticated(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(String failedValue)? noTeamSelected,
    TResult Function(String failedValue)? exceededPrice,
    TResult Function(String failedValue)? exceededTeamCount,
    TResult Function(String failedValue)? incompleteTeam,
    TResult Function(String failedValue)? deadlinePassed,
    TResult Function(String failedValue)? unauthenticated,
    TResult Function(String failedValue)? unauthorized,
    TResult Function(String failedValue)? noConnection,
    TResult Function(String failedValue)? socketError,
    TResult Function(String failedValue)? handShakeError,
    TResult Function(String failedValue)? unexpectedError,
    TResult Function(String failedValue)? hiveError,
    TResult Function(String failedValue)? sharedPreferencesError,
    TResult Function(String failedValue)? secureStorageError,
  }) {
    return unauthenticated?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String failedValue)? noTeamSelected,
    TResult Function(String failedValue)? exceededPrice,
    TResult Function(String failedValue)? exceededTeamCount,
    TResult Function(String failedValue)? incompleteTeam,
    TResult Function(String failedValue)? deadlinePassed,
    TResult Function(String failedValue)? unauthenticated,
    TResult Function(String failedValue)? unauthorized,
    TResult Function(String failedValue)? noConnection,
    TResult Function(String failedValue)? socketError,
    TResult Function(String failedValue)? handShakeError,
    TResult Function(String failedValue)? unexpectedError,
    TResult Function(String failedValue)? hiveError,
    TResult Function(String failedValue)? sharedPreferencesError,
    TResult Function(String failedValue)? secureStorageError,
    required TResult orElse(),
  }) {
    if (unauthenticated != null) {
      return unauthenticated(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NoTeamSelected<T> value) noTeamSelected,
    required TResult Function(ExceededPrice<T> value) exceededPrice,
    required TResult Function(ExceededTeamCount<T> value) exceededTeamCount,
    required TResult Function(IncompleteTeam<T> value) incompleteTeam,
    required TResult Function(DeadlinePassed<T> value) deadlinePassed,
    required TResult Function(Unauthenticated<T> value) unauthenticated,
    required TResult Function(Unauthorized<T> value) unauthorized,
    required TResult Function(NoConnection<T> value) noConnection,
    required TResult Function(SocketError<T> value) socketError,
    required TResult Function(HandShakeError<T> value) handShakeError,
    required TResult Function(UnexpectedError<T> value) unexpectedError,
    required TResult Function(HiveError<T> value) hiveError,
    required TResult Function(SharedPreferencesError<T> value)
        sharedPreferencesError,
    required TResult Function(SecureStorageError<T> value) secureStorageError,
  }) {
    return unauthenticated(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(NoTeamSelected<T> value)? noTeamSelected,
    TResult Function(ExceededPrice<T> value)? exceededPrice,
    TResult Function(ExceededTeamCount<T> value)? exceededTeamCount,
    TResult Function(IncompleteTeam<T> value)? incompleteTeam,
    TResult Function(DeadlinePassed<T> value)? deadlinePassed,
    TResult Function(Unauthenticated<T> value)? unauthenticated,
    TResult Function(Unauthorized<T> value)? unauthorized,
    TResult Function(NoConnection<T> value)? noConnection,
    TResult Function(SocketError<T> value)? socketError,
    TResult Function(HandShakeError<T> value)? handShakeError,
    TResult Function(UnexpectedError<T> value)? unexpectedError,
    TResult Function(HiveError<T> value)? hiveError,
    TResult Function(SharedPreferencesError<T> value)? sharedPreferencesError,
    TResult Function(SecureStorageError<T> value)? secureStorageError,
  }) {
    return unauthenticated?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NoTeamSelected<T> value)? noTeamSelected,
    TResult Function(ExceededPrice<T> value)? exceededPrice,
    TResult Function(ExceededTeamCount<T> value)? exceededTeamCount,
    TResult Function(IncompleteTeam<T> value)? incompleteTeam,
    TResult Function(DeadlinePassed<T> value)? deadlinePassed,
    TResult Function(Unauthenticated<T> value)? unauthenticated,
    TResult Function(Unauthorized<T> value)? unauthorized,
    TResult Function(NoConnection<T> value)? noConnection,
    TResult Function(SocketError<T> value)? socketError,
    TResult Function(HandShakeError<T> value)? handShakeError,
    TResult Function(UnexpectedError<T> value)? unexpectedError,
    TResult Function(HiveError<T> value)? hiveError,
    TResult Function(SharedPreferencesError<T> value)? sharedPreferencesError,
    TResult Function(SecureStorageError<T> value)? secureStorageError,
    required TResult orElse(),
  }) {
    if (unauthenticated != null) {
      return unauthenticated(this);
    }
    return orElse();
  }
}

abstract class Unauthenticated<T> implements TransferFailure<T> {
  const factory Unauthenticated({required String failedValue}) =
      _$Unauthenticated<T>;

  @override
  String get failedValue;
  @override
  @JsonKey(ignore: true)
  $UnauthenticatedCopyWith<T, Unauthenticated<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UnauthorizedCopyWith<T, $Res>
    implements $TransferFailureCopyWith<T, $Res> {
  factory $UnauthorizedCopyWith(
          Unauthorized<T> value, $Res Function(Unauthorized<T>) then) =
      _$UnauthorizedCopyWithImpl<T, $Res>;
  @override
  $Res call({String failedValue});
}

/// @nodoc
class _$UnauthorizedCopyWithImpl<T, $Res>
    extends _$TransferFailureCopyWithImpl<T, $Res>
    implements $UnauthorizedCopyWith<T, $Res> {
  _$UnauthorizedCopyWithImpl(
      Unauthorized<T> _value, $Res Function(Unauthorized<T>) _then)
      : super(_value, (v) => _then(v as Unauthorized<T>));

  @override
  Unauthorized<T> get _value => super._value as Unauthorized<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(Unauthorized<T>(
      failedValue: failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$Unauthorized<T> implements Unauthorized<T> {
  const _$Unauthorized({required this.failedValue});

  @override
  final String failedValue;

  @override
  String toString() {
    return 'TransferFailure<$T>.unauthorized(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is Unauthorized<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  @JsonKey(ignore: true)
  @override
  $UnauthorizedCopyWith<T, Unauthorized<T>> get copyWith =>
      _$UnauthorizedCopyWithImpl<T, Unauthorized<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String failedValue) noTeamSelected,
    required TResult Function(String failedValue) exceededPrice,
    required TResult Function(String failedValue) exceededTeamCount,
    required TResult Function(String failedValue) incompleteTeam,
    required TResult Function(String failedValue) deadlinePassed,
    required TResult Function(String failedValue) unauthenticated,
    required TResult Function(String failedValue) unauthorized,
    required TResult Function(String failedValue) noConnection,
    required TResult Function(String failedValue) socketError,
    required TResult Function(String failedValue) handShakeError,
    required TResult Function(String failedValue) unexpectedError,
    required TResult Function(String failedValue) hiveError,
    required TResult Function(String failedValue) sharedPreferencesError,
    required TResult Function(String failedValue) secureStorageError,
  }) {
    return unauthorized(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(String failedValue)? noTeamSelected,
    TResult Function(String failedValue)? exceededPrice,
    TResult Function(String failedValue)? exceededTeamCount,
    TResult Function(String failedValue)? incompleteTeam,
    TResult Function(String failedValue)? deadlinePassed,
    TResult Function(String failedValue)? unauthenticated,
    TResult Function(String failedValue)? unauthorized,
    TResult Function(String failedValue)? noConnection,
    TResult Function(String failedValue)? socketError,
    TResult Function(String failedValue)? handShakeError,
    TResult Function(String failedValue)? unexpectedError,
    TResult Function(String failedValue)? hiveError,
    TResult Function(String failedValue)? sharedPreferencesError,
    TResult Function(String failedValue)? secureStorageError,
  }) {
    return unauthorized?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String failedValue)? noTeamSelected,
    TResult Function(String failedValue)? exceededPrice,
    TResult Function(String failedValue)? exceededTeamCount,
    TResult Function(String failedValue)? incompleteTeam,
    TResult Function(String failedValue)? deadlinePassed,
    TResult Function(String failedValue)? unauthenticated,
    TResult Function(String failedValue)? unauthorized,
    TResult Function(String failedValue)? noConnection,
    TResult Function(String failedValue)? socketError,
    TResult Function(String failedValue)? handShakeError,
    TResult Function(String failedValue)? unexpectedError,
    TResult Function(String failedValue)? hiveError,
    TResult Function(String failedValue)? sharedPreferencesError,
    TResult Function(String failedValue)? secureStorageError,
    required TResult orElse(),
  }) {
    if (unauthorized != null) {
      return unauthorized(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NoTeamSelected<T> value) noTeamSelected,
    required TResult Function(ExceededPrice<T> value) exceededPrice,
    required TResult Function(ExceededTeamCount<T> value) exceededTeamCount,
    required TResult Function(IncompleteTeam<T> value) incompleteTeam,
    required TResult Function(DeadlinePassed<T> value) deadlinePassed,
    required TResult Function(Unauthenticated<T> value) unauthenticated,
    required TResult Function(Unauthorized<T> value) unauthorized,
    required TResult Function(NoConnection<T> value) noConnection,
    required TResult Function(SocketError<T> value) socketError,
    required TResult Function(HandShakeError<T> value) handShakeError,
    required TResult Function(UnexpectedError<T> value) unexpectedError,
    required TResult Function(HiveError<T> value) hiveError,
    required TResult Function(SharedPreferencesError<T> value)
        sharedPreferencesError,
    required TResult Function(SecureStorageError<T> value) secureStorageError,
  }) {
    return unauthorized(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(NoTeamSelected<T> value)? noTeamSelected,
    TResult Function(ExceededPrice<T> value)? exceededPrice,
    TResult Function(ExceededTeamCount<T> value)? exceededTeamCount,
    TResult Function(IncompleteTeam<T> value)? incompleteTeam,
    TResult Function(DeadlinePassed<T> value)? deadlinePassed,
    TResult Function(Unauthenticated<T> value)? unauthenticated,
    TResult Function(Unauthorized<T> value)? unauthorized,
    TResult Function(NoConnection<T> value)? noConnection,
    TResult Function(SocketError<T> value)? socketError,
    TResult Function(HandShakeError<T> value)? handShakeError,
    TResult Function(UnexpectedError<T> value)? unexpectedError,
    TResult Function(HiveError<T> value)? hiveError,
    TResult Function(SharedPreferencesError<T> value)? sharedPreferencesError,
    TResult Function(SecureStorageError<T> value)? secureStorageError,
  }) {
    return unauthorized?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NoTeamSelected<T> value)? noTeamSelected,
    TResult Function(ExceededPrice<T> value)? exceededPrice,
    TResult Function(ExceededTeamCount<T> value)? exceededTeamCount,
    TResult Function(IncompleteTeam<T> value)? incompleteTeam,
    TResult Function(DeadlinePassed<T> value)? deadlinePassed,
    TResult Function(Unauthenticated<T> value)? unauthenticated,
    TResult Function(Unauthorized<T> value)? unauthorized,
    TResult Function(NoConnection<T> value)? noConnection,
    TResult Function(SocketError<T> value)? socketError,
    TResult Function(HandShakeError<T> value)? handShakeError,
    TResult Function(UnexpectedError<T> value)? unexpectedError,
    TResult Function(HiveError<T> value)? hiveError,
    TResult Function(SharedPreferencesError<T> value)? sharedPreferencesError,
    TResult Function(SecureStorageError<T> value)? secureStorageError,
    required TResult orElse(),
  }) {
    if (unauthorized != null) {
      return unauthorized(this);
    }
    return orElse();
  }
}

abstract class Unauthorized<T> implements TransferFailure<T> {
  const factory Unauthorized({required String failedValue}) = _$Unauthorized<T>;

  @override
  String get failedValue;
  @override
  @JsonKey(ignore: true)
  $UnauthorizedCopyWith<T, Unauthorized<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $NoConnectionCopyWith<T, $Res>
    implements $TransferFailureCopyWith<T, $Res> {
  factory $NoConnectionCopyWith(
          NoConnection<T> value, $Res Function(NoConnection<T>) then) =
      _$NoConnectionCopyWithImpl<T, $Res>;
  @override
  $Res call({String failedValue});
}

/// @nodoc
class _$NoConnectionCopyWithImpl<T, $Res>
    extends _$TransferFailureCopyWithImpl<T, $Res>
    implements $NoConnectionCopyWith<T, $Res> {
  _$NoConnectionCopyWithImpl(
      NoConnection<T> _value, $Res Function(NoConnection<T>) _then)
      : super(_value, (v) => _then(v as NoConnection<T>));

  @override
  NoConnection<T> get _value => super._value as NoConnection<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(NoConnection<T>(
      failedValue: failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$NoConnection<T> implements NoConnection<T> {
  const _$NoConnection({required this.failedValue});

  @override
  final String failedValue;

  @override
  String toString() {
    return 'TransferFailure<$T>.noConnection(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is NoConnection<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  @JsonKey(ignore: true)
  @override
  $NoConnectionCopyWith<T, NoConnection<T>> get copyWith =>
      _$NoConnectionCopyWithImpl<T, NoConnection<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String failedValue) noTeamSelected,
    required TResult Function(String failedValue) exceededPrice,
    required TResult Function(String failedValue) exceededTeamCount,
    required TResult Function(String failedValue) incompleteTeam,
    required TResult Function(String failedValue) deadlinePassed,
    required TResult Function(String failedValue) unauthenticated,
    required TResult Function(String failedValue) unauthorized,
    required TResult Function(String failedValue) noConnection,
    required TResult Function(String failedValue) socketError,
    required TResult Function(String failedValue) handShakeError,
    required TResult Function(String failedValue) unexpectedError,
    required TResult Function(String failedValue) hiveError,
    required TResult Function(String failedValue) sharedPreferencesError,
    required TResult Function(String failedValue) secureStorageError,
  }) {
    return noConnection(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(String failedValue)? noTeamSelected,
    TResult Function(String failedValue)? exceededPrice,
    TResult Function(String failedValue)? exceededTeamCount,
    TResult Function(String failedValue)? incompleteTeam,
    TResult Function(String failedValue)? deadlinePassed,
    TResult Function(String failedValue)? unauthenticated,
    TResult Function(String failedValue)? unauthorized,
    TResult Function(String failedValue)? noConnection,
    TResult Function(String failedValue)? socketError,
    TResult Function(String failedValue)? handShakeError,
    TResult Function(String failedValue)? unexpectedError,
    TResult Function(String failedValue)? hiveError,
    TResult Function(String failedValue)? sharedPreferencesError,
    TResult Function(String failedValue)? secureStorageError,
  }) {
    return noConnection?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String failedValue)? noTeamSelected,
    TResult Function(String failedValue)? exceededPrice,
    TResult Function(String failedValue)? exceededTeamCount,
    TResult Function(String failedValue)? incompleteTeam,
    TResult Function(String failedValue)? deadlinePassed,
    TResult Function(String failedValue)? unauthenticated,
    TResult Function(String failedValue)? unauthorized,
    TResult Function(String failedValue)? noConnection,
    TResult Function(String failedValue)? socketError,
    TResult Function(String failedValue)? handShakeError,
    TResult Function(String failedValue)? unexpectedError,
    TResult Function(String failedValue)? hiveError,
    TResult Function(String failedValue)? sharedPreferencesError,
    TResult Function(String failedValue)? secureStorageError,
    required TResult orElse(),
  }) {
    if (noConnection != null) {
      return noConnection(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NoTeamSelected<T> value) noTeamSelected,
    required TResult Function(ExceededPrice<T> value) exceededPrice,
    required TResult Function(ExceededTeamCount<T> value) exceededTeamCount,
    required TResult Function(IncompleteTeam<T> value) incompleteTeam,
    required TResult Function(DeadlinePassed<T> value) deadlinePassed,
    required TResult Function(Unauthenticated<T> value) unauthenticated,
    required TResult Function(Unauthorized<T> value) unauthorized,
    required TResult Function(NoConnection<T> value) noConnection,
    required TResult Function(SocketError<T> value) socketError,
    required TResult Function(HandShakeError<T> value) handShakeError,
    required TResult Function(UnexpectedError<T> value) unexpectedError,
    required TResult Function(HiveError<T> value) hiveError,
    required TResult Function(SharedPreferencesError<T> value)
        sharedPreferencesError,
    required TResult Function(SecureStorageError<T> value) secureStorageError,
  }) {
    return noConnection(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(NoTeamSelected<T> value)? noTeamSelected,
    TResult Function(ExceededPrice<T> value)? exceededPrice,
    TResult Function(ExceededTeamCount<T> value)? exceededTeamCount,
    TResult Function(IncompleteTeam<T> value)? incompleteTeam,
    TResult Function(DeadlinePassed<T> value)? deadlinePassed,
    TResult Function(Unauthenticated<T> value)? unauthenticated,
    TResult Function(Unauthorized<T> value)? unauthorized,
    TResult Function(NoConnection<T> value)? noConnection,
    TResult Function(SocketError<T> value)? socketError,
    TResult Function(HandShakeError<T> value)? handShakeError,
    TResult Function(UnexpectedError<T> value)? unexpectedError,
    TResult Function(HiveError<T> value)? hiveError,
    TResult Function(SharedPreferencesError<T> value)? sharedPreferencesError,
    TResult Function(SecureStorageError<T> value)? secureStorageError,
  }) {
    return noConnection?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NoTeamSelected<T> value)? noTeamSelected,
    TResult Function(ExceededPrice<T> value)? exceededPrice,
    TResult Function(ExceededTeamCount<T> value)? exceededTeamCount,
    TResult Function(IncompleteTeam<T> value)? incompleteTeam,
    TResult Function(DeadlinePassed<T> value)? deadlinePassed,
    TResult Function(Unauthenticated<T> value)? unauthenticated,
    TResult Function(Unauthorized<T> value)? unauthorized,
    TResult Function(NoConnection<T> value)? noConnection,
    TResult Function(SocketError<T> value)? socketError,
    TResult Function(HandShakeError<T> value)? handShakeError,
    TResult Function(UnexpectedError<T> value)? unexpectedError,
    TResult Function(HiveError<T> value)? hiveError,
    TResult Function(SharedPreferencesError<T> value)? sharedPreferencesError,
    TResult Function(SecureStorageError<T> value)? secureStorageError,
    required TResult orElse(),
  }) {
    if (noConnection != null) {
      return noConnection(this);
    }
    return orElse();
  }
}

abstract class NoConnection<T> implements TransferFailure<T> {
  const factory NoConnection({required String failedValue}) = _$NoConnection<T>;

  @override
  String get failedValue;
  @override
  @JsonKey(ignore: true)
  $NoConnectionCopyWith<T, NoConnection<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SocketErrorCopyWith<T, $Res>
    implements $TransferFailureCopyWith<T, $Res> {
  factory $SocketErrorCopyWith(
          SocketError<T> value, $Res Function(SocketError<T>) then) =
      _$SocketErrorCopyWithImpl<T, $Res>;
  @override
  $Res call({String failedValue});
}

/// @nodoc
class _$SocketErrorCopyWithImpl<T, $Res>
    extends _$TransferFailureCopyWithImpl<T, $Res>
    implements $SocketErrorCopyWith<T, $Res> {
  _$SocketErrorCopyWithImpl(
      SocketError<T> _value, $Res Function(SocketError<T>) _then)
      : super(_value, (v) => _then(v as SocketError<T>));

  @override
  SocketError<T> get _value => super._value as SocketError<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(SocketError<T>(
      failedValue: failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$SocketError<T> implements SocketError<T> {
  const _$SocketError({required this.failedValue});

  @override
  final String failedValue;

  @override
  String toString() {
    return 'TransferFailure<$T>.socketError(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is SocketError<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  @JsonKey(ignore: true)
  @override
  $SocketErrorCopyWith<T, SocketError<T>> get copyWith =>
      _$SocketErrorCopyWithImpl<T, SocketError<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String failedValue) noTeamSelected,
    required TResult Function(String failedValue) exceededPrice,
    required TResult Function(String failedValue) exceededTeamCount,
    required TResult Function(String failedValue) incompleteTeam,
    required TResult Function(String failedValue) deadlinePassed,
    required TResult Function(String failedValue) unauthenticated,
    required TResult Function(String failedValue) unauthorized,
    required TResult Function(String failedValue) noConnection,
    required TResult Function(String failedValue) socketError,
    required TResult Function(String failedValue) handShakeError,
    required TResult Function(String failedValue) unexpectedError,
    required TResult Function(String failedValue) hiveError,
    required TResult Function(String failedValue) sharedPreferencesError,
    required TResult Function(String failedValue) secureStorageError,
  }) {
    return socketError(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(String failedValue)? noTeamSelected,
    TResult Function(String failedValue)? exceededPrice,
    TResult Function(String failedValue)? exceededTeamCount,
    TResult Function(String failedValue)? incompleteTeam,
    TResult Function(String failedValue)? deadlinePassed,
    TResult Function(String failedValue)? unauthenticated,
    TResult Function(String failedValue)? unauthorized,
    TResult Function(String failedValue)? noConnection,
    TResult Function(String failedValue)? socketError,
    TResult Function(String failedValue)? handShakeError,
    TResult Function(String failedValue)? unexpectedError,
    TResult Function(String failedValue)? hiveError,
    TResult Function(String failedValue)? sharedPreferencesError,
    TResult Function(String failedValue)? secureStorageError,
  }) {
    return socketError?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String failedValue)? noTeamSelected,
    TResult Function(String failedValue)? exceededPrice,
    TResult Function(String failedValue)? exceededTeamCount,
    TResult Function(String failedValue)? incompleteTeam,
    TResult Function(String failedValue)? deadlinePassed,
    TResult Function(String failedValue)? unauthenticated,
    TResult Function(String failedValue)? unauthorized,
    TResult Function(String failedValue)? noConnection,
    TResult Function(String failedValue)? socketError,
    TResult Function(String failedValue)? handShakeError,
    TResult Function(String failedValue)? unexpectedError,
    TResult Function(String failedValue)? hiveError,
    TResult Function(String failedValue)? sharedPreferencesError,
    TResult Function(String failedValue)? secureStorageError,
    required TResult orElse(),
  }) {
    if (socketError != null) {
      return socketError(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NoTeamSelected<T> value) noTeamSelected,
    required TResult Function(ExceededPrice<T> value) exceededPrice,
    required TResult Function(ExceededTeamCount<T> value) exceededTeamCount,
    required TResult Function(IncompleteTeam<T> value) incompleteTeam,
    required TResult Function(DeadlinePassed<T> value) deadlinePassed,
    required TResult Function(Unauthenticated<T> value) unauthenticated,
    required TResult Function(Unauthorized<T> value) unauthorized,
    required TResult Function(NoConnection<T> value) noConnection,
    required TResult Function(SocketError<T> value) socketError,
    required TResult Function(HandShakeError<T> value) handShakeError,
    required TResult Function(UnexpectedError<T> value) unexpectedError,
    required TResult Function(HiveError<T> value) hiveError,
    required TResult Function(SharedPreferencesError<T> value)
        sharedPreferencesError,
    required TResult Function(SecureStorageError<T> value) secureStorageError,
  }) {
    return socketError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(NoTeamSelected<T> value)? noTeamSelected,
    TResult Function(ExceededPrice<T> value)? exceededPrice,
    TResult Function(ExceededTeamCount<T> value)? exceededTeamCount,
    TResult Function(IncompleteTeam<T> value)? incompleteTeam,
    TResult Function(DeadlinePassed<T> value)? deadlinePassed,
    TResult Function(Unauthenticated<T> value)? unauthenticated,
    TResult Function(Unauthorized<T> value)? unauthorized,
    TResult Function(NoConnection<T> value)? noConnection,
    TResult Function(SocketError<T> value)? socketError,
    TResult Function(HandShakeError<T> value)? handShakeError,
    TResult Function(UnexpectedError<T> value)? unexpectedError,
    TResult Function(HiveError<T> value)? hiveError,
    TResult Function(SharedPreferencesError<T> value)? sharedPreferencesError,
    TResult Function(SecureStorageError<T> value)? secureStorageError,
  }) {
    return socketError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NoTeamSelected<T> value)? noTeamSelected,
    TResult Function(ExceededPrice<T> value)? exceededPrice,
    TResult Function(ExceededTeamCount<T> value)? exceededTeamCount,
    TResult Function(IncompleteTeam<T> value)? incompleteTeam,
    TResult Function(DeadlinePassed<T> value)? deadlinePassed,
    TResult Function(Unauthenticated<T> value)? unauthenticated,
    TResult Function(Unauthorized<T> value)? unauthorized,
    TResult Function(NoConnection<T> value)? noConnection,
    TResult Function(SocketError<T> value)? socketError,
    TResult Function(HandShakeError<T> value)? handShakeError,
    TResult Function(UnexpectedError<T> value)? unexpectedError,
    TResult Function(HiveError<T> value)? hiveError,
    TResult Function(SharedPreferencesError<T> value)? sharedPreferencesError,
    TResult Function(SecureStorageError<T> value)? secureStorageError,
    required TResult orElse(),
  }) {
    if (socketError != null) {
      return socketError(this);
    }
    return orElse();
  }
}

abstract class SocketError<T> implements TransferFailure<T> {
  const factory SocketError({required String failedValue}) = _$SocketError<T>;

  @override
  String get failedValue;
  @override
  @JsonKey(ignore: true)
  $SocketErrorCopyWith<T, SocketError<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $HandShakeErrorCopyWith<T, $Res>
    implements $TransferFailureCopyWith<T, $Res> {
  factory $HandShakeErrorCopyWith(
          HandShakeError<T> value, $Res Function(HandShakeError<T>) then) =
      _$HandShakeErrorCopyWithImpl<T, $Res>;
  @override
  $Res call({String failedValue});
}

/// @nodoc
class _$HandShakeErrorCopyWithImpl<T, $Res>
    extends _$TransferFailureCopyWithImpl<T, $Res>
    implements $HandShakeErrorCopyWith<T, $Res> {
  _$HandShakeErrorCopyWithImpl(
      HandShakeError<T> _value, $Res Function(HandShakeError<T>) _then)
      : super(_value, (v) => _then(v as HandShakeError<T>));

  @override
  HandShakeError<T> get _value => super._value as HandShakeError<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(HandShakeError<T>(
      failedValue: failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$HandShakeError<T> implements HandShakeError<T> {
  const _$HandShakeError({required this.failedValue});

  @override
  final String failedValue;

  @override
  String toString() {
    return 'TransferFailure<$T>.handShakeError(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is HandShakeError<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  @JsonKey(ignore: true)
  @override
  $HandShakeErrorCopyWith<T, HandShakeError<T>> get copyWith =>
      _$HandShakeErrorCopyWithImpl<T, HandShakeError<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String failedValue) noTeamSelected,
    required TResult Function(String failedValue) exceededPrice,
    required TResult Function(String failedValue) exceededTeamCount,
    required TResult Function(String failedValue) incompleteTeam,
    required TResult Function(String failedValue) deadlinePassed,
    required TResult Function(String failedValue) unauthenticated,
    required TResult Function(String failedValue) unauthorized,
    required TResult Function(String failedValue) noConnection,
    required TResult Function(String failedValue) socketError,
    required TResult Function(String failedValue) handShakeError,
    required TResult Function(String failedValue) unexpectedError,
    required TResult Function(String failedValue) hiveError,
    required TResult Function(String failedValue) sharedPreferencesError,
    required TResult Function(String failedValue) secureStorageError,
  }) {
    return handShakeError(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(String failedValue)? noTeamSelected,
    TResult Function(String failedValue)? exceededPrice,
    TResult Function(String failedValue)? exceededTeamCount,
    TResult Function(String failedValue)? incompleteTeam,
    TResult Function(String failedValue)? deadlinePassed,
    TResult Function(String failedValue)? unauthenticated,
    TResult Function(String failedValue)? unauthorized,
    TResult Function(String failedValue)? noConnection,
    TResult Function(String failedValue)? socketError,
    TResult Function(String failedValue)? handShakeError,
    TResult Function(String failedValue)? unexpectedError,
    TResult Function(String failedValue)? hiveError,
    TResult Function(String failedValue)? sharedPreferencesError,
    TResult Function(String failedValue)? secureStorageError,
  }) {
    return handShakeError?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String failedValue)? noTeamSelected,
    TResult Function(String failedValue)? exceededPrice,
    TResult Function(String failedValue)? exceededTeamCount,
    TResult Function(String failedValue)? incompleteTeam,
    TResult Function(String failedValue)? deadlinePassed,
    TResult Function(String failedValue)? unauthenticated,
    TResult Function(String failedValue)? unauthorized,
    TResult Function(String failedValue)? noConnection,
    TResult Function(String failedValue)? socketError,
    TResult Function(String failedValue)? handShakeError,
    TResult Function(String failedValue)? unexpectedError,
    TResult Function(String failedValue)? hiveError,
    TResult Function(String failedValue)? sharedPreferencesError,
    TResult Function(String failedValue)? secureStorageError,
    required TResult orElse(),
  }) {
    if (handShakeError != null) {
      return handShakeError(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NoTeamSelected<T> value) noTeamSelected,
    required TResult Function(ExceededPrice<T> value) exceededPrice,
    required TResult Function(ExceededTeamCount<T> value) exceededTeamCount,
    required TResult Function(IncompleteTeam<T> value) incompleteTeam,
    required TResult Function(DeadlinePassed<T> value) deadlinePassed,
    required TResult Function(Unauthenticated<T> value) unauthenticated,
    required TResult Function(Unauthorized<T> value) unauthorized,
    required TResult Function(NoConnection<T> value) noConnection,
    required TResult Function(SocketError<T> value) socketError,
    required TResult Function(HandShakeError<T> value) handShakeError,
    required TResult Function(UnexpectedError<T> value) unexpectedError,
    required TResult Function(HiveError<T> value) hiveError,
    required TResult Function(SharedPreferencesError<T> value)
        sharedPreferencesError,
    required TResult Function(SecureStorageError<T> value) secureStorageError,
  }) {
    return handShakeError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(NoTeamSelected<T> value)? noTeamSelected,
    TResult Function(ExceededPrice<T> value)? exceededPrice,
    TResult Function(ExceededTeamCount<T> value)? exceededTeamCount,
    TResult Function(IncompleteTeam<T> value)? incompleteTeam,
    TResult Function(DeadlinePassed<T> value)? deadlinePassed,
    TResult Function(Unauthenticated<T> value)? unauthenticated,
    TResult Function(Unauthorized<T> value)? unauthorized,
    TResult Function(NoConnection<T> value)? noConnection,
    TResult Function(SocketError<T> value)? socketError,
    TResult Function(HandShakeError<T> value)? handShakeError,
    TResult Function(UnexpectedError<T> value)? unexpectedError,
    TResult Function(HiveError<T> value)? hiveError,
    TResult Function(SharedPreferencesError<T> value)? sharedPreferencesError,
    TResult Function(SecureStorageError<T> value)? secureStorageError,
  }) {
    return handShakeError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NoTeamSelected<T> value)? noTeamSelected,
    TResult Function(ExceededPrice<T> value)? exceededPrice,
    TResult Function(ExceededTeamCount<T> value)? exceededTeamCount,
    TResult Function(IncompleteTeam<T> value)? incompleteTeam,
    TResult Function(DeadlinePassed<T> value)? deadlinePassed,
    TResult Function(Unauthenticated<T> value)? unauthenticated,
    TResult Function(Unauthorized<T> value)? unauthorized,
    TResult Function(NoConnection<T> value)? noConnection,
    TResult Function(SocketError<T> value)? socketError,
    TResult Function(HandShakeError<T> value)? handShakeError,
    TResult Function(UnexpectedError<T> value)? unexpectedError,
    TResult Function(HiveError<T> value)? hiveError,
    TResult Function(SharedPreferencesError<T> value)? sharedPreferencesError,
    TResult Function(SecureStorageError<T> value)? secureStorageError,
    required TResult orElse(),
  }) {
    if (handShakeError != null) {
      return handShakeError(this);
    }
    return orElse();
  }
}

abstract class HandShakeError<T> implements TransferFailure<T> {
  const factory HandShakeError({required String failedValue}) =
      _$HandShakeError<T>;

  @override
  String get failedValue;
  @override
  @JsonKey(ignore: true)
  $HandShakeErrorCopyWith<T, HandShakeError<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UnexpectedErrorCopyWith<T, $Res>
    implements $TransferFailureCopyWith<T, $Res> {
  factory $UnexpectedErrorCopyWith(
          UnexpectedError<T> value, $Res Function(UnexpectedError<T>) then) =
      _$UnexpectedErrorCopyWithImpl<T, $Res>;
  @override
  $Res call({String failedValue});
}

/// @nodoc
class _$UnexpectedErrorCopyWithImpl<T, $Res>
    extends _$TransferFailureCopyWithImpl<T, $Res>
    implements $UnexpectedErrorCopyWith<T, $Res> {
  _$UnexpectedErrorCopyWithImpl(
      UnexpectedError<T> _value, $Res Function(UnexpectedError<T>) _then)
      : super(_value, (v) => _then(v as UnexpectedError<T>));

  @override
  UnexpectedError<T> get _value => super._value as UnexpectedError<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(UnexpectedError<T>(
      failedValue: failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$UnexpectedError<T> implements UnexpectedError<T> {
  const _$UnexpectedError({required this.failedValue});

  @override
  final String failedValue;

  @override
  String toString() {
    return 'TransferFailure<$T>.unexpectedError(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is UnexpectedError<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  @JsonKey(ignore: true)
  @override
  $UnexpectedErrorCopyWith<T, UnexpectedError<T>> get copyWith =>
      _$UnexpectedErrorCopyWithImpl<T, UnexpectedError<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String failedValue) noTeamSelected,
    required TResult Function(String failedValue) exceededPrice,
    required TResult Function(String failedValue) exceededTeamCount,
    required TResult Function(String failedValue) incompleteTeam,
    required TResult Function(String failedValue) deadlinePassed,
    required TResult Function(String failedValue) unauthenticated,
    required TResult Function(String failedValue) unauthorized,
    required TResult Function(String failedValue) noConnection,
    required TResult Function(String failedValue) socketError,
    required TResult Function(String failedValue) handShakeError,
    required TResult Function(String failedValue) unexpectedError,
    required TResult Function(String failedValue) hiveError,
    required TResult Function(String failedValue) sharedPreferencesError,
    required TResult Function(String failedValue) secureStorageError,
  }) {
    return unexpectedError(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(String failedValue)? noTeamSelected,
    TResult Function(String failedValue)? exceededPrice,
    TResult Function(String failedValue)? exceededTeamCount,
    TResult Function(String failedValue)? incompleteTeam,
    TResult Function(String failedValue)? deadlinePassed,
    TResult Function(String failedValue)? unauthenticated,
    TResult Function(String failedValue)? unauthorized,
    TResult Function(String failedValue)? noConnection,
    TResult Function(String failedValue)? socketError,
    TResult Function(String failedValue)? handShakeError,
    TResult Function(String failedValue)? unexpectedError,
    TResult Function(String failedValue)? hiveError,
    TResult Function(String failedValue)? sharedPreferencesError,
    TResult Function(String failedValue)? secureStorageError,
  }) {
    return unexpectedError?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String failedValue)? noTeamSelected,
    TResult Function(String failedValue)? exceededPrice,
    TResult Function(String failedValue)? exceededTeamCount,
    TResult Function(String failedValue)? incompleteTeam,
    TResult Function(String failedValue)? deadlinePassed,
    TResult Function(String failedValue)? unauthenticated,
    TResult Function(String failedValue)? unauthorized,
    TResult Function(String failedValue)? noConnection,
    TResult Function(String failedValue)? socketError,
    TResult Function(String failedValue)? handShakeError,
    TResult Function(String failedValue)? unexpectedError,
    TResult Function(String failedValue)? hiveError,
    TResult Function(String failedValue)? sharedPreferencesError,
    TResult Function(String failedValue)? secureStorageError,
    required TResult orElse(),
  }) {
    if (unexpectedError != null) {
      return unexpectedError(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NoTeamSelected<T> value) noTeamSelected,
    required TResult Function(ExceededPrice<T> value) exceededPrice,
    required TResult Function(ExceededTeamCount<T> value) exceededTeamCount,
    required TResult Function(IncompleteTeam<T> value) incompleteTeam,
    required TResult Function(DeadlinePassed<T> value) deadlinePassed,
    required TResult Function(Unauthenticated<T> value) unauthenticated,
    required TResult Function(Unauthorized<T> value) unauthorized,
    required TResult Function(NoConnection<T> value) noConnection,
    required TResult Function(SocketError<T> value) socketError,
    required TResult Function(HandShakeError<T> value) handShakeError,
    required TResult Function(UnexpectedError<T> value) unexpectedError,
    required TResult Function(HiveError<T> value) hiveError,
    required TResult Function(SharedPreferencesError<T> value)
        sharedPreferencesError,
    required TResult Function(SecureStorageError<T> value) secureStorageError,
  }) {
    return unexpectedError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(NoTeamSelected<T> value)? noTeamSelected,
    TResult Function(ExceededPrice<T> value)? exceededPrice,
    TResult Function(ExceededTeamCount<T> value)? exceededTeamCount,
    TResult Function(IncompleteTeam<T> value)? incompleteTeam,
    TResult Function(DeadlinePassed<T> value)? deadlinePassed,
    TResult Function(Unauthenticated<T> value)? unauthenticated,
    TResult Function(Unauthorized<T> value)? unauthorized,
    TResult Function(NoConnection<T> value)? noConnection,
    TResult Function(SocketError<T> value)? socketError,
    TResult Function(HandShakeError<T> value)? handShakeError,
    TResult Function(UnexpectedError<T> value)? unexpectedError,
    TResult Function(HiveError<T> value)? hiveError,
    TResult Function(SharedPreferencesError<T> value)? sharedPreferencesError,
    TResult Function(SecureStorageError<T> value)? secureStorageError,
  }) {
    return unexpectedError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NoTeamSelected<T> value)? noTeamSelected,
    TResult Function(ExceededPrice<T> value)? exceededPrice,
    TResult Function(ExceededTeamCount<T> value)? exceededTeamCount,
    TResult Function(IncompleteTeam<T> value)? incompleteTeam,
    TResult Function(DeadlinePassed<T> value)? deadlinePassed,
    TResult Function(Unauthenticated<T> value)? unauthenticated,
    TResult Function(Unauthorized<T> value)? unauthorized,
    TResult Function(NoConnection<T> value)? noConnection,
    TResult Function(SocketError<T> value)? socketError,
    TResult Function(HandShakeError<T> value)? handShakeError,
    TResult Function(UnexpectedError<T> value)? unexpectedError,
    TResult Function(HiveError<T> value)? hiveError,
    TResult Function(SharedPreferencesError<T> value)? sharedPreferencesError,
    TResult Function(SecureStorageError<T> value)? secureStorageError,
    required TResult orElse(),
  }) {
    if (unexpectedError != null) {
      return unexpectedError(this);
    }
    return orElse();
  }
}

abstract class UnexpectedError<T> implements TransferFailure<T> {
  const factory UnexpectedError({required String failedValue}) =
      _$UnexpectedError<T>;

  @override
  String get failedValue;
  @override
  @JsonKey(ignore: true)
  $UnexpectedErrorCopyWith<T, UnexpectedError<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $HiveErrorCopyWith<T, $Res>
    implements $TransferFailureCopyWith<T, $Res> {
  factory $HiveErrorCopyWith(
          HiveError<T> value, $Res Function(HiveError<T>) then) =
      _$HiveErrorCopyWithImpl<T, $Res>;
  @override
  $Res call({String failedValue});
}

/// @nodoc
class _$HiveErrorCopyWithImpl<T, $Res>
    extends _$TransferFailureCopyWithImpl<T, $Res>
    implements $HiveErrorCopyWith<T, $Res> {
  _$HiveErrorCopyWithImpl(
      HiveError<T> _value, $Res Function(HiveError<T>) _then)
      : super(_value, (v) => _then(v as HiveError<T>));

  @override
  HiveError<T> get _value => super._value as HiveError<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(HiveError<T>(
      failedValue: failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$HiveError<T> implements HiveError<T> {
  const _$HiveError({required this.failedValue});

  @override
  final String failedValue;

  @override
  String toString() {
    return 'TransferFailure<$T>.hiveError(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is HiveError<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  @JsonKey(ignore: true)
  @override
  $HiveErrorCopyWith<T, HiveError<T>> get copyWith =>
      _$HiveErrorCopyWithImpl<T, HiveError<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String failedValue) noTeamSelected,
    required TResult Function(String failedValue) exceededPrice,
    required TResult Function(String failedValue) exceededTeamCount,
    required TResult Function(String failedValue) incompleteTeam,
    required TResult Function(String failedValue) deadlinePassed,
    required TResult Function(String failedValue) unauthenticated,
    required TResult Function(String failedValue) unauthorized,
    required TResult Function(String failedValue) noConnection,
    required TResult Function(String failedValue) socketError,
    required TResult Function(String failedValue) handShakeError,
    required TResult Function(String failedValue) unexpectedError,
    required TResult Function(String failedValue) hiveError,
    required TResult Function(String failedValue) sharedPreferencesError,
    required TResult Function(String failedValue) secureStorageError,
  }) {
    return hiveError(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(String failedValue)? noTeamSelected,
    TResult Function(String failedValue)? exceededPrice,
    TResult Function(String failedValue)? exceededTeamCount,
    TResult Function(String failedValue)? incompleteTeam,
    TResult Function(String failedValue)? deadlinePassed,
    TResult Function(String failedValue)? unauthenticated,
    TResult Function(String failedValue)? unauthorized,
    TResult Function(String failedValue)? noConnection,
    TResult Function(String failedValue)? socketError,
    TResult Function(String failedValue)? handShakeError,
    TResult Function(String failedValue)? unexpectedError,
    TResult Function(String failedValue)? hiveError,
    TResult Function(String failedValue)? sharedPreferencesError,
    TResult Function(String failedValue)? secureStorageError,
  }) {
    return hiveError?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String failedValue)? noTeamSelected,
    TResult Function(String failedValue)? exceededPrice,
    TResult Function(String failedValue)? exceededTeamCount,
    TResult Function(String failedValue)? incompleteTeam,
    TResult Function(String failedValue)? deadlinePassed,
    TResult Function(String failedValue)? unauthenticated,
    TResult Function(String failedValue)? unauthorized,
    TResult Function(String failedValue)? noConnection,
    TResult Function(String failedValue)? socketError,
    TResult Function(String failedValue)? handShakeError,
    TResult Function(String failedValue)? unexpectedError,
    TResult Function(String failedValue)? hiveError,
    TResult Function(String failedValue)? sharedPreferencesError,
    TResult Function(String failedValue)? secureStorageError,
    required TResult orElse(),
  }) {
    if (hiveError != null) {
      return hiveError(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NoTeamSelected<T> value) noTeamSelected,
    required TResult Function(ExceededPrice<T> value) exceededPrice,
    required TResult Function(ExceededTeamCount<T> value) exceededTeamCount,
    required TResult Function(IncompleteTeam<T> value) incompleteTeam,
    required TResult Function(DeadlinePassed<T> value) deadlinePassed,
    required TResult Function(Unauthenticated<T> value) unauthenticated,
    required TResult Function(Unauthorized<T> value) unauthorized,
    required TResult Function(NoConnection<T> value) noConnection,
    required TResult Function(SocketError<T> value) socketError,
    required TResult Function(HandShakeError<T> value) handShakeError,
    required TResult Function(UnexpectedError<T> value) unexpectedError,
    required TResult Function(HiveError<T> value) hiveError,
    required TResult Function(SharedPreferencesError<T> value)
        sharedPreferencesError,
    required TResult Function(SecureStorageError<T> value) secureStorageError,
  }) {
    return hiveError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(NoTeamSelected<T> value)? noTeamSelected,
    TResult Function(ExceededPrice<T> value)? exceededPrice,
    TResult Function(ExceededTeamCount<T> value)? exceededTeamCount,
    TResult Function(IncompleteTeam<T> value)? incompleteTeam,
    TResult Function(DeadlinePassed<T> value)? deadlinePassed,
    TResult Function(Unauthenticated<T> value)? unauthenticated,
    TResult Function(Unauthorized<T> value)? unauthorized,
    TResult Function(NoConnection<T> value)? noConnection,
    TResult Function(SocketError<T> value)? socketError,
    TResult Function(HandShakeError<T> value)? handShakeError,
    TResult Function(UnexpectedError<T> value)? unexpectedError,
    TResult Function(HiveError<T> value)? hiveError,
    TResult Function(SharedPreferencesError<T> value)? sharedPreferencesError,
    TResult Function(SecureStorageError<T> value)? secureStorageError,
  }) {
    return hiveError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NoTeamSelected<T> value)? noTeamSelected,
    TResult Function(ExceededPrice<T> value)? exceededPrice,
    TResult Function(ExceededTeamCount<T> value)? exceededTeamCount,
    TResult Function(IncompleteTeam<T> value)? incompleteTeam,
    TResult Function(DeadlinePassed<T> value)? deadlinePassed,
    TResult Function(Unauthenticated<T> value)? unauthenticated,
    TResult Function(Unauthorized<T> value)? unauthorized,
    TResult Function(NoConnection<T> value)? noConnection,
    TResult Function(SocketError<T> value)? socketError,
    TResult Function(HandShakeError<T> value)? handShakeError,
    TResult Function(UnexpectedError<T> value)? unexpectedError,
    TResult Function(HiveError<T> value)? hiveError,
    TResult Function(SharedPreferencesError<T> value)? sharedPreferencesError,
    TResult Function(SecureStorageError<T> value)? secureStorageError,
    required TResult orElse(),
  }) {
    if (hiveError != null) {
      return hiveError(this);
    }
    return orElse();
  }
}

abstract class HiveError<T> implements TransferFailure<T> {
  const factory HiveError({required String failedValue}) = _$HiveError<T>;

  @override
  String get failedValue;
  @override
  @JsonKey(ignore: true)
  $HiveErrorCopyWith<T, HiveError<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SharedPreferencesErrorCopyWith<T, $Res>
    implements $TransferFailureCopyWith<T, $Res> {
  factory $SharedPreferencesErrorCopyWith(SharedPreferencesError<T> value,
          $Res Function(SharedPreferencesError<T>) then) =
      _$SharedPreferencesErrorCopyWithImpl<T, $Res>;
  @override
  $Res call({String failedValue});
}

/// @nodoc
class _$SharedPreferencesErrorCopyWithImpl<T, $Res>
    extends _$TransferFailureCopyWithImpl<T, $Res>
    implements $SharedPreferencesErrorCopyWith<T, $Res> {
  _$SharedPreferencesErrorCopyWithImpl(SharedPreferencesError<T> _value,
      $Res Function(SharedPreferencesError<T>) _then)
      : super(_value, (v) => _then(v as SharedPreferencesError<T>));

  @override
  SharedPreferencesError<T> get _value =>
      super._value as SharedPreferencesError<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(SharedPreferencesError<T>(
      failedValue: failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$SharedPreferencesError<T> implements SharedPreferencesError<T> {
  const _$SharedPreferencesError({required this.failedValue});

  @override
  final String failedValue;

  @override
  String toString() {
    return 'TransferFailure<$T>.sharedPreferencesError(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is SharedPreferencesError<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  @JsonKey(ignore: true)
  @override
  $SharedPreferencesErrorCopyWith<T, SharedPreferencesError<T>> get copyWith =>
      _$SharedPreferencesErrorCopyWithImpl<T, SharedPreferencesError<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String failedValue) noTeamSelected,
    required TResult Function(String failedValue) exceededPrice,
    required TResult Function(String failedValue) exceededTeamCount,
    required TResult Function(String failedValue) incompleteTeam,
    required TResult Function(String failedValue) deadlinePassed,
    required TResult Function(String failedValue) unauthenticated,
    required TResult Function(String failedValue) unauthorized,
    required TResult Function(String failedValue) noConnection,
    required TResult Function(String failedValue) socketError,
    required TResult Function(String failedValue) handShakeError,
    required TResult Function(String failedValue) unexpectedError,
    required TResult Function(String failedValue) hiveError,
    required TResult Function(String failedValue) sharedPreferencesError,
    required TResult Function(String failedValue) secureStorageError,
  }) {
    return sharedPreferencesError(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(String failedValue)? noTeamSelected,
    TResult Function(String failedValue)? exceededPrice,
    TResult Function(String failedValue)? exceededTeamCount,
    TResult Function(String failedValue)? incompleteTeam,
    TResult Function(String failedValue)? deadlinePassed,
    TResult Function(String failedValue)? unauthenticated,
    TResult Function(String failedValue)? unauthorized,
    TResult Function(String failedValue)? noConnection,
    TResult Function(String failedValue)? socketError,
    TResult Function(String failedValue)? handShakeError,
    TResult Function(String failedValue)? unexpectedError,
    TResult Function(String failedValue)? hiveError,
    TResult Function(String failedValue)? sharedPreferencesError,
    TResult Function(String failedValue)? secureStorageError,
  }) {
    return sharedPreferencesError?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String failedValue)? noTeamSelected,
    TResult Function(String failedValue)? exceededPrice,
    TResult Function(String failedValue)? exceededTeamCount,
    TResult Function(String failedValue)? incompleteTeam,
    TResult Function(String failedValue)? deadlinePassed,
    TResult Function(String failedValue)? unauthenticated,
    TResult Function(String failedValue)? unauthorized,
    TResult Function(String failedValue)? noConnection,
    TResult Function(String failedValue)? socketError,
    TResult Function(String failedValue)? handShakeError,
    TResult Function(String failedValue)? unexpectedError,
    TResult Function(String failedValue)? hiveError,
    TResult Function(String failedValue)? sharedPreferencesError,
    TResult Function(String failedValue)? secureStorageError,
    required TResult orElse(),
  }) {
    if (sharedPreferencesError != null) {
      return sharedPreferencesError(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NoTeamSelected<T> value) noTeamSelected,
    required TResult Function(ExceededPrice<T> value) exceededPrice,
    required TResult Function(ExceededTeamCount<T> value) exceededTeamCount,
    required TResult Function(IncompleteTeam<T> value) incompleteTeam,
    required TResult Function(DeadlinePassed<T> value) deadlinePassed,
    required TResult Function(Unauthenticated<T> value) unauthenticated,
    required TResult Function(Unauthorized<T> value) unauthorized,
    required TResult Function(NoConnection<T> value) noConnection,
    required TResult Function(SocketError<T> value) socketError,
    required TResult Function(HandShakeError<T> value) handShakeError,
    required TResult Function(UnexpectedError<T> value) unexpectedError,
    required TResult Function(HiveError<T> value) hiveError,
    required TResult Function(SharedPreferencesError<T> value)
        sharedPreferencesError,
    required TResult Function(SecureStorageError<T> value) secureStorageError,
  }) {
    return sharedPreferencesError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(NoTeamSelected<T> value)? noTeamSelected,
    TResult Function(ExceededPrice<T> value)? exceededPrice,
    TResult Function(ExceededTeamCount<T> value)? exceededTeamCount,
    TResult Function(IncompleteTeam<T> value)? incompleteTeam,
    TResult Function(DeadlinePassed<T> value)? deadlinePassed,
    TResult Function(Unauthenticated<T> value)? unauthenticated,
    TResult Function(Unauthorized<T> value)? unauthorized,
    TResult Function(NoConnection<T> value)? noConnection,
    TResult Function(SocketError<T> value)? socketError,
    TResult Function(HandShakeError<T> value)? handShakeError,
    TResult Function(UnexpectedError<T> value)? unexpectedError,
    TResult Function(HiveError<T> value)? hiveError,
    TResult Function(SharedPreferencesError<T> value)? sharedPreferencesError,
    TResult Function(SecureStorageError<T> value)? secureStorageError,
  }) {
    return sharedPreferencesError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NoTeamSelected<T> value)? noTeamSelected,
    TResult Function(ExceededPrice<T> value)? exceededPrice,
    TResult Function(ExceededTeamCount<T> value)? exceededTeamCount,
    TResult Function(IncompleteTeam<T> value)? incompleteTeam,
    TResult Function(DeadlinePassed<T> value)? deadlinePassed,
    TResult Function(Unauthenticated<T> value)? unauthenticated,
    TResult Function(Unauthorized<T> value)? unauthorized,
    TResult Function(NoConnection<T> value)? noConnection,
    TResult Function(SocketError<T> value)? socketError,
    TResult Function(HandShakeError<T> value)? handShakeError,
    TResult Function(UnexpectedError<T> value)? unexpectedError,
    TResult Function(HiveError<T> value)? hiveError,
    TResult Function(SharedPreferencesError<T> value)? sharedPreferencesError,
    TResult Function(SecureStorageError<T> value)? secureStorageError,
    required TResult orElse(),
  }) {
    if (sharedPreferencesError != null) {
      return sharedPreferencesError(this);
    }
    return orElse();
  }
}

abstract class SharedPreferencesError<T> implements TransferFailure<T> {
  const factory SharedPreferencesError({required String failedValue}) =
      _$SharedPreferencesError<T>;

  @override
  String get failedValue;
  @override
  @JsonKey(ignore: true)
  $SharedPreferencesErrorCopyWith<T, SharedPreferencesError<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SecureStorageErrorCopyWith<T, $Res>
    implements $TransferFailureCopyWith<T, $Res> {
  factory $SecureStorageErrorCopyWith(SecureStorageError<T> value,
          $Res Function(SecureStorageError<T>) then) =
      _$SecureStorageErrorCopyWithImpl<T, $Res>;
  @override
  $Res call({String failedValue});
}

/// @nodoc
class _$SecureStorageErrorCopyWithImpl<T, $Res>
    extends _$TransferFailureCopyWithImpl<T, $Res>
    implements $SecureStorageErrorCopyWith<T, $Res> {
  _$SecureStorageErrorCopyWithImpl(
      SecureStorageError<T> _value, $Res Function(SecureStorageError<T>) _then)
      : super(_value, (v) => _then(v as SecureStorageError<T>));

  @override
  SecureStorageError<T> get _value => super._value as SecureStorageError<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(SecureStorageError<T>(
      failedValue: failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$SecureStorageError<T> implements SecureStorageError<T> {
  const _$SecureStorageError({required this.failedValue});

  @override
  final String failedValue;

  @override
  String toString() {
    return 'TransferFailure<$T>.secureStorageError(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is SecureStorageError<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  @JsonKey(ignore: true)
  @override
  $SecureStorageErrorCopyWith<T, SecureStorageError<T>> get copyWith =>
      _$SecureStorageErrorCopyWithImpl<T, SecureStorageError<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String failedValue) noTeamSelected,
    required TResult Function(String failedValue) exceededPrice,
    required TResult Function(String failedValue) exceededTeamCount,
    required TResult Function(String failedValue) incompleteTeam,
    required TResult Function(String failedValue) deadlinePassed,
    required TResult Function(String failedValue) unauthenticated,
    required TResult Function(String failedValue) unauthorized,
    required TResult Function(String failedValue) noConnection,
    required TResult Function(String failedValue) socketError,
    required TResult Function(String failedValue) handShakeError,
    required TResult Function(String failedValue) unexpectedError,
    required TResult Function(String failedValue) hiveError,
    required TResult Function(String failedValue) sharedPreferencesError,
    required TResult Function(String failedValue) secureStorageError,
  }) {
    return secureStorageError(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(String failedValue)? noTeamSelected,
    TResult Function(String failedValue)? exceededPrice,
    TResult Function(String failedValue)? exceededTeamCount,
    TResult Function(String failedValue)? incompleteTeam,
    TResult Function(String failedValue)? deadlinePassed,
    TResult Function(String failedValue)? unauthenticated,
    TResult Function(String failedValue)? unauthorized,
    TResult Function(String failedValue)? noConnection,
    TResult Function(String failedValue)? socketError,
    TResult Function(String failedValue)? handShakeError,
    TResult Function(String failedValue)? unexpectedError,
    TResult Function(String failedValue)? hiveError,
    TResult Function(String failedValue)? sharedPreferencesError,
    TResult Function(String failedValue)? secureStorageError,
  }) {
    return secureStorageError?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String failedValue)? noTeamSelected,
    TResult Function(String failedValue)? exceededPrice,
    TResult Function(String failedValue)? exceededTeamCount,
    TResult Function(String failedValue)? incompleteTeam,
    TResult Function(String failedValue)? deadlinePassed,
    TResult Function(String failedValue)? unauthenticated,
    TResult Function(String failedValue)? unauthorized,
    TResult Function(String failedValue)? noConnection,
    TResult Function(String failedValue)? socketError,
    TResult Function(String failedValue)? handShakeError,
    TResult Function(String failedValue)? unexpectedError,
    TResult Function(String failedValue)? hiveError,
    TResult Function(String failedValue)? sharedPreferencesError,
    TResult Function(String failedValue)? secureStorageError,
    required TResult orElse(),
  }) {
    if (secureStorageError != null) {
      return secureStorageError(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NoTeamSelected<T> value) noTeamSelected,
    required TResult Function(ExceededPrice<T> value) exceededPrice,
    required TResult Function(ExceededTeamCount<T> value) exceededTeamCount,
    required TResult Function(IncompleteTeam<T> value) incompleteTeam,
    required TResult Function(DeadlinePassed<T> value) deadlinePassed,
    required TResult Function(Unauthenticated<T> value) unauthenticated,
    required TResult Function(Unauthorized<T> value) unauthorized,
    required TResult Function(NoConnection<T> value) noConnection,
    required TResult Function(SocketError<T> value) socketError,
    required TResult Function(HandShakeError<T> value) handShakeError,
    required TResult Function(UnexpectedError<T> value) unexpectedError,
    required TResult Function(HiveError<T> value) hiveError,
    required TResult Function(SharedPreferencesError<T> value)
        sharedPreferencesError,
    required TResult Function(SecureStorageError<T> value) secureStorageError,
  }) {
    return secureStorageError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(NoTeamSelected<T> value)? noTeamSelected,
    TResult Function(ExceededPrice<T> value)? exceededPrice,
    TResult Function(ExceededTeamCount<T> value)? exceededTeamCount,
    TResult Function(IncompleteTeam<T> value)? incompleteTeam,
    TResult Function(DeadlinePassed<T> value)? deadlinePassed,
    TResult Function(Unauthenticated<T> value)? unauthenticated,
    TResult Function(Unauthorized<T> value)? unauthorized,
    TResult Function(NoConnection<T> value)? noConnection,
    TResult Function(SocketError<T> value)? socketError,
    TResult Function(HandShakeError<T> value)? handShakeError,
    TResult Function(UnexpectedError<T> value)? unexpectedError,
    TResult Function(HiveError<T> value)? hiveError,
    TResult Function(SharedPreferencesError<T> value)? sharedPreferencesError,
    TResult Function(SecureStorageError<T> value)? secureStorageError,
  }) {
    return secureStorageError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NoTeamSelected<T> value)? noTeamSelected,
    TResult Function(ExceededPrice<T> value)? exceededPrice,
    TResult Function(ExceededTeamCount<T> value)? exceededTeamCount,
    TResult Function(IncompleteTeam<T> value)? incompleteTeam,
    TResult Function(DeadlinePassed<T> value)? deadlinePassed,
    TResult Function(Unauthenticated<T> value)? unauthenticated,
    TResult Function(Unauthorized<T> value)? unauthorized,
    TResult Function(NoConnection<T> value)? noConnection,
    TResult Function(SocketError<T> value)? socketError,
    TResult Function(HandShakeError<T> value)? handShakeError,
    TResult Function(UnexpectedError<T> value)? unexpectedError,
    TResult Function(HiveError<T> value)? hiveError,
    TResult Function(SharedPreferencesError<T> value)? sharedPreferencesError,
    TResult Function(SecureStorageError<T> value)? secureStorageError,
    required TResult orElse(),
  }) {
    if (secureStorageError != null) {
      return secureStorageError(this);
    }
    return orElse();
  }
}

abstract class SecureStorageError<T> implements TransferFailure<T> {
  const factory SecureStorageError({required String failedValue}) =
      _$SecureStorageError<T>;

  @override
  String get failedValue;
  @override
  @JsonKey(ignore: true)
  $SecureStorageErrorCopyWith<T, SecureStorageError<T>> get copyWith =>
      throw _privateConstructorUsedError;
}
