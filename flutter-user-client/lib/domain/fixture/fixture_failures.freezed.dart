// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'fixture_failures.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$FixtureFailuresTearOff {
  const _$FixtureFailuresTearOff();

  Unauthenticated<T> unauthenticated<T>({required String failedValue}) {
    return Unauthenticated<T>(
      failedValue: failedValue,
    );
  }

  Unauthorized<T> unauthorized<T>({required String failedValue}) {
    return Unauthorized<T>(
      failedValue: failedValue,
    );
  }

  NoConnection<T> noConnection<T>({required String failedValue}) {
    return NoConnection<T>(
      failedValue: failedValue,
    );
  }

  SocketError<T> socketError<T>({required String failedValue}) {
    return SocketError<T>(
      failedValue: failedValue,
    );
  }

  HandShakeError<T> handShakeError<T>({required String failedValue}) {
    return HandShakeError<T>(
      failedValue: failedValue,
    );
  }

  UnexpectedError<T> unexpectedError<T>({required String failedValue}) {
    return UnexpectedError<T>(
      failedValue: failedValue,
    );
  }

  HiveError<T> hiveError<T>({required T failedValue}) {
    return HiveError<T>(
      failedValue: failedValue,
    );
  }

  SharedPreferencesError<T> sharedPreferencesError<T>(
      {required T failedValue}) {
    return SharedPreferencesError<T>(
      failedValue: failedValue,
    );
  }

  SecureStorageError<T> secureStorageError<T>({required T failedValue}) {
    return SecureStorageError<T>(
      failedValue: failedValue,
    );
  }
}

/// @nodoc
const $FixtureFailures = _$FixtureFailuresTearOff();

/// @nodoc
mixin _$FixtureFailures<T> {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String failedValue) unauthenticated,
    required TResult Function(String failedValue) unauthorized,
    required TResult Function(String failedValue) noConnection,
    required TResult Function(String failedValue) socketError,
    required TResult Function(String failedValue) handShakeError,
    required TResult Function(String failedValue) unexpectedError,
    required TResult Function(T failedValue) hiveError,
    required TResult Function(T failedValue) sharedPreferencesError,
    required TResult Function(T failedValue) secureStorageError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(String failedValue)? unauthenticated,
    TResult Function(String failedValue)? unauthorized,
    TResult Function(String failedValue)? noConnection,
    TResult Function(String failedValue)? socketError,
    TResult Function(String failedValue)? handShakeError,
    TResult Function(String failedValue)? unexpectedError,
    TResult Function(T failedValue)? hiveError,
    TResult Function(T failedValue)? sharedPreferencesError,
    TResult Function(T failedValue)? secureStorageError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String failedValue)? unauthenticated,
    TResult Function(String failedValue)? unauthorized,
    TResult Function(String failedValue)? noConnection,
    TResult Function(String failedValue)? socketError,
    TResult Function(String failedValue)? handShakeError,
    TResult Function(String failedValue)? unexpectedError,
    TResult Function(T failedValue)? hiveError,
    TResult Function(T failedValue)? sharedPreferencesError,
    TResult Function(T failedValue)? secureStorageError,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Unauthenticated<T> value) unauthenticated,
    required TResult Function(Unauthorized<T> value) unauthorized,
    required TResult Function(NoConnection<T> value) noConnection,
    required TResult Function(SocketError<T> value) socketError,
    required TResult Function(HandShakeError<T> value) handShakeError,
    required TResult Function(UnexpectedError<T> value) unexpectedError,
    required TResult Function(HiveError<T> value) hiveError,
    required TResult Function(SharedPreferencesError<T> value)
        sharedPreferencesError,
    required TResult Function(SecureStorageError<T> value) secureStorageError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Unauthenticated<T> value)? unauthenticated,
    TResult Function(Unauthorized<T> value)? unauthorized,
    TResult Function(NoConnection<T> value)? noConnection,
    TResult Function(SocketError<T> value)? socketError,
    TResult Function(HandShakeError<T> value)? handShakeError,
    TResult Function(UnexpectedError<T> value)? unexpectedError,
    TResult Function(HiveError<T> value)? hiveError,
    TResult Function(SharedPreferencesError<T> value)? sharedPreferencesError,
    TResult Function(SecureStorageError<T> value)? secureStorageError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Unauthenticated<T> value)? unauthenticated,
    TResult Function(Unauthorized<T> value)? unauthorized,
    TResult Function(NoConnection<T> value)? noConnection,
    TResult Function(SocketError<T> value)? socketError,
    TResult Function(HandShakeError<T> value)? handShakeError,
    TResult Function(UnexpectedError<T> value)? unexpectedError,
    TResult Function(HiveError<T> value)? hiveError,
    TResult Function(SharedPreferencesError<T> value)? sharedPreferencesError,
    TResult Function(SecureStorageError<T> value)? secureStorageError,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FixtureFailuresCopyWith<T, $Res> {
  factory $FixtureFailuresCopyWith(
          FixtureFailures<T> value, $Res Function(FixtureFailures<T>) then) =
      _$FixtureFailuresCopyWithImpl<T, $Res>;
}

/// @nodoc
class _$FixtureFailuresCopyWithImpl<T, $Res>
    implements $FixtureFailuresCopyWith<T, $Res> {
  _$FixtureFailuresCopyWithImpl(this._value, this._then);

  final FixtureFailures<T> _value;
  // ignore: unused_field
  final $Res Function(FixtureFailures<T>) _then;
}

/// @nodoc
abstract class $UnauthenticatedCopyWith<T, $Res> {
  factory $UnauthenticatedCopyWith(
          Unauthenticated<T> value, $Res Function(Unauthenticated<T>) then) =
      _$UnauthenticatedCopyWithImpl<T, $Res>;
  $Res call({String failedValue});
}

/// @nodoc
class _$UnauthenticatedCopyWithImpl<T, $Res>
    extends _$FixtureFailuresCopyWithImpl<T, $Res>
    implements $UnauthenticatedCopyWith<T, $Res> {
  _$UnauthenticatedCopyWithImpl(
      Unauthenticated<T> _value, $Res Function(Unauthenticated<T>) _then)
      : super(_value, (v) => _then(v as Unauthenticated<T>));

  @override
  Unauthenticated<T> get _value => super._value as Unauthenticated<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(Unauthenticated<T>(
      failedValue: failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$Unauthenticated<T> implements Unauthenticated<T> {
  const _$Unauthenticated({required this.failedValue});

  @override
  final String failedValue;

  @override
  String toString() {
    return 'FixtureFailures<$T>.unauthenticated(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is Unauthenticated<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  @JsonKey(ignore: true)
  @override
  $UnauthenticatedCopyWith<T, Unauthenticated<T>> get copyWith =>
      _$UnauthenticatedCopyWithImpl<T, Unauthenticated<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String failedValue) unauthenticated,
    required TResult Function(String failedValue) unauthorized,
    required TResult Function(String failedValue) noConnection,
    required TResult Function(String failedValue) socketError,
    required TResult Function(String failedValue) handShakeError,
    required TResult Function(String failedValue) unexpectedError,
    required TResult Function(T failedValue) hiveError,
    required TResult Function(T failedValue) sharedPreferencesError,
    required TResult Function(T failedValue) secureStorageError,
  }) {
    return unauthenticated(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(String failedValue)? unauthenticated,
    TResult Function(String failedValue)? unauthorized,
    TResult Function(String failedValue)? noConnection,
    TResult Function(String failedValue)? socketError,
    TResult Function(String failedValue)? handShakeError,
    TResult Function(String failedValue)? unexpectedError,
    TResult Function(T failedValue)? hiveError,
    TResult Function(T failedValue)? sharedPreferencesError,
    TResult Function(T failedValue)? secureStorageError,
  }) {
    return unauthenticated?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String failedValue)? unauthenticated,
    TResult Function(String failedValue)? unauthorized,
    TResult Function(String failedValue)? noConnection,
    TResult Function(String failedValue)? socketError,
    TResult Function(String failedValue)? handShakeError,
    TResult Function(String failedValue)? unexpectedError,
    TResult Function(T failedValue)? hiveError,
    TResult Function(T failedValue)? sharedPreferencesError,
    TResult Function(T failedValue)? secureStorageError,
    required TResult orElse(),
  }) {
    if (unauthenticated != null) {
      return unauthenticated(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Unauthenticated<T> value) unauthenticated,
    required TResult Function(Unauthorized<T> value) unauthorized,
    required TResult Function(NoConnection<T> value) noConnection,
    required TResult Function(SocketError<T> value) socketError,
    required TResult Function(HandShakeError<T> value) handShakeError,
    required TResult Function(UnexpectedError<T> value) unexpectedError,
    required TResult Function(HiveError<T> value) hiveError,
    required TResult Function(SharedPreferencesError<T> value)
        sharedPreferencesError,
    required TResult Function(SecureStorageError<T> value) secureStorageError,
  }) {
    return unauthenticated(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Unauthenticated<T> value)? unauthenticated,
    TResult Function(Unauthorized<T> value)? unauthorized,
    TResult Function(NoConnection<T> value)? noConnection,
    TResult Function(SocketError<T> value)? socketError,
    TResult Function(HandShakeError<T> value)? handShakeError,
    TResult Function(UnexpectedError<T> value)? unexpectedError,
    TResult Function(HiveError<T> value)? hiveError,
    TResult Function(SharedPreferencesError<T> value)? sharedPreferencesError,
    TResult Function(SecureStorageError<T> value)? secureStorageError,
  }) {
    return unauthenticated?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Unauthenticated<T> value)? unauthenticated,
    TResult Function(Unauthorized<T> value)? unauthorized,
    TResult Function(NoConnection<T> value)? noConnection,
    TResult Function(SocketError<T> value)? socketError,
    TResult Function(HandShakeError<T> value)? handShakeError,
    TResult Function(UnexpectedError<T> value)? unexpectedError,
    TResult Function(HiveError<T> value)? hiveError,
    TResult Function(SharedPreferencesError<T> value)? sharedPreferencesError,
    TResult Function(SecureStorageError<T> value)? secureStorageError,
    required TResult orElse(),
  }) {
    if (unauthenticated != null) {
      return unauthenticated(this);
    }
    return orElse();
  }
}

abstract class Unauthenticated<T> implements FixtureFailures<T> {
  const factory Unauthenticated({required String failedValue}) =
      _$Unauthenticated<T>;

  String get failedValue;
  @JsonKey(ignore: true)
  $UnauthenticatedCopyWith<T, Unauthenticated<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UnauthorizedCopyWith<T, $Res> {
  factory $UnauthorizedCopyWith(
          Unauthorized<T> value, $Res Function(Unauthorized<T>) then) =
      _$UnauthorizedCopyWithImpl<T, $Res>;
  $Res call({String failedValue});
}

/// @nodoc
class _$UnauthorizedCopyWithImpl<T, $Res>
    extends _$FixtureFailuresCopyWithImpl<T, $Res>
    implements $UnauthorizedCopyWith<T, $Res> {
  _$UnauthorizedCopyWithImpl(
      Unauthorized<T> _value, $Res Function(Unauthorized<T>) _then)
      : super(_value, (v) => _then(v as Unauthorized<T>));

  @override
  Unauthorized<T> get _value => super._value as Unauthorized<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(Unauthorized<T>(
      failedValue: failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$Unauthorized<T> implements Unauthorized<T> {
  const _$Unauthorized({required this.failedValue});

  @override
  final String failedValue;

  @override
  String toString() {
    return 'FixtureFailures<$T>.unauthorized(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is Unauthorized<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  @JsonKey(ignore: true)
  @override
  $UnauthorizedCopyWith<T, Unauthorized<T>> get copyWith =>
      _$UnauthorizedCopyWithImpl<T, Unauthorized<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String failedValue) unauthenticated,
    required TResult Function(String failedValue) unauthorized,
    required TResult Function(String failedValue) noConnection,
    required TResult Function(String failedValue) socketError,
    required TResult Function(String failedValue) handShakeError,
    required TResult Function(String failedValue) unexpectedError,
    required TResult Function(T failedValue) hiveError,
    required TResult Function(T failedValue) sharedPreferencesError,
    required TResult Function(T failedValue) secureStorageError,
  }) {
    return unauthorized(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(String failedValue)? unauthenticated,
    TResult Function(String failedValue)? unauthorized,
    TResult Function(String failedValue)? noConnection,
    TResult Function(String failedValue)? socketError,
    TResult Function(String failedValue)? handShakeError,
    TResult Function(String failedValue)? unexpectedError,
    TResult Function(T failedValue)? hiveError,
    TResult Function(T failedValue)? sharedPreferencesError,
    TResult Function(T failedValue)? secureStorageError,
  }) {
    return unauthorized?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String failedValue)? unauthenticated,
    TResult Function(String failedValue)? unauthorized,
    TResult Function(String failedValue)? noConnection,
    TResult Function(String failedValue)? socketError,
    TResult Function(String failedValue)? handShakeError,
    TResult Function(String failedValue)? unexpectedError,
    TResult Function(T failedValue)? hiveError,
    TResult Function(T failedValue)? sharedPreferencesError,
    TResult Function(T failedValue)? secureStorageError,
    required TResult orElse(),
  }) {
    if (unauthorized != null) {
      return unauthorized(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Unauthenticated<T> value) unauthenticated,
    required TResult Function(Unauthorized<T> value) unauthorized,
    required TResult Function(NoConnection<T> value) noConnection,
    required TResult Function(SocketError<T> value) socketError,
    required TResult Function(HandShakeError<T> value) handShakeError,
    required TResult Function(UnexpectedError<T> value) unexpectedError,
    required TResult Function(HiveError<T> value) hiveError,
    required TResult Function(SharedPreferencesError<T> value)
        sharedPreferencesError,
    required TResult Function(SecureStorageError<T> value) secureStorageError,
  }) {
    return unauthorized(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Unauthenticated<T> value)? unauthenticated,
    TResult Function(Unauthorized<T> value)? unauthorized,
    TResult Function(NoConnection<T> value)? noConnection,
    TResult Function(SocketError<T> value)? socketError,
    TResult Function(HandShakeError<T> value)? handShakeError,
    TResult Function(UnexpectedError<T> value)? unexpectedError,
    TResult Function(HiveError<T> value)? hiveError,
    TResult Function(SharedPreferencesError<T> value)? sharedPreferencesError,
    TResult Function(SecureStorageError<T> value)? secureStorageError,
  }) {
    return unauthorized?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Unauthenticated<T> value)? unauthenticated,
    TResult Function(Unauthorized<T> value)? unauthorized,
    TResult Function(NoConnection<T> value)? noConnection,
    TResult Function(SocketError<T> value)? socketError,
    TResult Function(HandShakeError<T> value)? handShakeError,
    TResult Function(UnexpectedError<T> value)? unexpectedError,
    TResult Function(HiveError<T> value)? hiveError,
    TResult Function(SharedPreferencesError<T> value)? sharedPreferencesError,
    TResult Function(SecureStorageError<T> value)? secureStorageError,
    required TResult orElse(),
  }) {
    if (unauthorized != null) {
      return unauthorized(this);
    }
    return orElse();
  }
}

abstract class Unauthorized<T> implements FixtureFailures<T> {
  const factory Unauthorized({required String failedValue}) = _$Unauthorized<T>;

  String get failedValue;
  @JsonKey(ignore: true)
  $UnauthorizedCopyWith<T, Unauthorized<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $NoConnectionCopyWith<T, $Res> {
  factory $NoConnectionCopyWith(
          NoConnection<T> value, $Res Function(NoConnection<T>) then) =
      _$NoConnectionCopyWithImpl<T, $Res>;
  $Res call({String failedValue});
}

/// @nodoc
class _$NoConnectionCopyWithImpl<T, $Res>
    extends _$FixtureFailuresCopyWithImpl<T, $Res>
    implements $NoConnectionCopyWith<T, $Res> {
  _$NoConnectionCopyWithImpl(
      NoConnection<T> _value, $Res Function(NoConnection<T>) _then)
      : super(_value, (v) => _then(v as NoConnection<T>));

  @override
  NoConnection<T> get _value => super._value as NoConnection<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(NoConnection<T>(
      failedValue: failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$NoConnection<T> implements NoConnection<T> {
  const _$NoConnection({required this.failedValue});

  @override
  final String failedValue;

  @override
  String toString() {
    return 'FixtureFailures<$T>.noConnection(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is NoConnection<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  @JsonKey(ignore: true)
  @override
  $NoConnectionCopyWith<T, NoConnection<T>> get copyWith =>
      _$NoConnectionCopyWithImpl<T, NoConnection<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String failedValue) unauthenticated,
    required TResult Function(String failedValue) unauthorized,
    required TResult Function(String failedValue) noConnection,
    required TResult Function(String failedValue) socketError,
    required TResult Function(String failedValue) handShakeError,
    required TResult Function(String failedValue) unexpectedError,
    required TResult Function(T failedValue) hiveError,
    required TResult Function(T failedValue) sharedPreferencesError,
    required TResult Function(T failedValue) secureStorageError,
  }) {
    return noConnection(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(String failedValue)? unauthenticated,
    TResult Function(String failedValue)? unauthorized,
    TResult Function(String failedValue)? noConnection,
    TResult Function(String failedValue)? socketError,
    TResult Function(String failedValue)? handShakeError,
    TResult Function(String failedValue)? unexpectedError,
    TResult Function(T failedValue)? hiveError,
    TResult Function(T failedValue)? sharedPreferencesError,
    TResult Function(T failedValue)? secureStorageError,
  }) {
    return noConnection?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String failedValue)? unauthenticated,
    TResult Function(String failedValue)? unauthorized,
    TResult Function(String failedValue)? noConnection,
    TResult Function(String failedValue)? socketError,
    TResult Function(String failedValue)? handShakeError,
    TResult Function(String failedValue)? unexpectedError,
    TResult Function(T failedValue)? hiveError,
    TResult Function(T failedValue)? sharedPreferencesError,
    TResult Function(T failedValue)? secureStorageError,
    required TResult orElse(),
  }) {
    if (noConnection != null) {
      return noConnection(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Unauthenticated<T> value) unauthenticated,
    required TResult Function(Unauthorized<T> value) unauthorized,
    required TResult Function(NoConnection<T> value) noConnection,
    required TResult Function(SocketError<T> value) socketError,
    required TResult Function(HandShakeError<T> value) handShakeError,
    required TResult Function(UnexpectedError<T> value) unexpectedError,
    required TResult Function(HiveError<T> value) hiveError,
    required TResult Function(SharedPreferencesError<T> value)
        sharedPreferencesError,
    required TResult Function(SecureStorageError<T> value) secureStorageError,
  }) {
    return noConnection(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Unauthenticated<T> value)? unauthenticated,
    TResult Function(Unauthorized<T> value)? unauthorized,
    TResult Function(NoConnection<T> value)? noConnection,
    TResult Function(SocketError<T> value)? socketError,
    TResult Function(HandShakeError<T> value)? handShakeError,
    TResult Function(UnexpectedError<T> value)? unexpectedError,
    TResult Function(HiveError<T> value)? hiveError,
    TResult Function(SharedPreferencesError<T> value)? sharedPreferencesError,
    TResult Function(SecureStorageError<T> value)? secureStorageError,
  }) {
    return noConnection?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Unauthenticated<T> value)? unauthenticated,
    TResult Function(Unauthorized<T> value)? unauthorized,
    TResult Function(NoConnection<T> value)? noConnection,
    TResult Function(SocketError<T> value)? socketError,
    TResult Function(HandShakeError<T> value)? handShakeError,
    TResult Function(UnexpectedError<T> value)? unexpectedError,
    TResult Function(HiveError<T> value)? hiveError,
    TResult Function(SharedPreferencesError<T> value)? sharedPreferencesError,
    TResult Function(SecureStorageError<T> value)? secureStorageError,
    required TResult orElse(),
  }) {
    if (noConnection != null) {
      return noConnection(this);
    }
    return orElse();
  }
}

abstract class NoConnection<T> implements FixtureFailures<T> {
  const factory NoConnection({required String failedValue}) = _$NoConnection<T>;

  String get failedValue;
  @JsonKey(ignore: true)
  $NoConnectionCopyWith<T, NoConnection<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SocketErrorCopyWith<T, $Res> {
  factory $SocketErrorCopyWith(
          SocketError<T> value, $Res Function(SocketError<T>) then) =
      _$SocketErrorCopyWithImpl<T, $Res>;
  $Res call({String failedValue});
}

/// @nodoc
class _$SocketErrorCopyWithImpl<T, $Res>
    extends _$FixtureFailuresCopyWithImpl<T, $Res>
    implements $SocketErrorCopyWith<T, $Res> {
  _$SocketErrorCopyWithImpl(
      SocketError<T> _value, $Res Function(SocketError<T>) _then)
      : super(_value, (v) => _then(v as SocketError<T>));

  @override
  SocketError<T> get _value => super._value as SocketError<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(SocketError<T>(
      failedValue: failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$SocketError<T> implements SocketError<T> {
  const _$SocketError({required this.failedValue});

  @override
  final String failedValue;

  @override
  String toString() {
    return 'FixtureFailures<$T>.socketError(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is SocketError<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  @JsonKey(ignore: true)
  @override
  $SocketErrorCopyWith<T, SocketError<T>> get copyWith =>
      _$SocketErrorCopyWithImpl<T, SocketError<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String failedValue) unauthenticated,
    required TResult Function(String failedValue) unauthorized,
    required TResult Function(String failedValue) noConnection,
    required TResult Function(String failedValue) socketError,
    required TResult Function(String failedValue) handShakeError,
    required TResult Function(String failedValue) unexpectedError,
    required TResult Function(T failedValue) hiveError,
    required TResult Function(T failedValue) sharedPreferencesError,
    required TResult Function(T failedValue) secureStorageError,
  }) {
    return socketError(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(String failedValue)? unauthenticated,
    TResult Function(String failedValue)? unauthorized,
    TResult Function(String failedValue)? noConnection,
    TResult Function(String failedValue)? socketError,
    TResult Function(String failedValue)? handShakeError,
    TResult Function(String failedValue)? unexpectedError,
    TResult Function(T failedValue)? hiveError,
    TResult Function(T failedValue)? sharedPreferencesError,
    TResult Function(T failedValue)? secureStorageError,
  }) {
    return socketError?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String failedValue)? unauthenticated,
    TResult Function(String failedValue)? unauthorized,
    TResult Function(String failedValue)? noConnection,
    TResult Function(String failedValue)? socketError,
    TResult Function(String failedValue)? handShakeError,
    TResult Function(String failedValue)? unexpectedError,
    TResult Function(T failedValue)? hiveError,
    TResult Function(T failedValue)? sharedPreferencesError,
    TResult Function(T failedValue)? secureStorageError,
    required TResult orElse(),
  }) {
    if (socketError != null) {
      return socketError(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Unauthenticated<T> value) unauthenticated,
    required TResult Function(Unauthorized<T> value) unauthorized,
    required TResult Function(NoConnection<T> value) noConnection,
    required TResult Function(SocketError<T> value) socketError,
    required TResult Function(HandShakeError<T> value) handShakeError,
    required TResult Function(UnexpectedError<T> value) unexpectedError,
    required TResult Function(HiveError<T> value) hiveError,
    required TResult Function(SharedPreferencesError<T> value)
        sharedPreferencesError,
    required TResult Function(SecureStorageError<T> value) secureStorageError,
  }) {
    return socketError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Unauthenticated<T> value)? unauthenticated,
    TResult Function(Unauthorized<T> value)? unauthorized,
    TResult Function(NoConnection<T> value)? noConnection,
    TResult Function(SocketError<T> value)? socketError,
    TResult Function(HandShakeError<T> value)? handShakeError,
    TResult Function(UnexpectedError<T> value)? unexpectedError,
    TResult Function(HiveError<T> value)? hiveError,
    TResult Function(SharedPreferencesError<T> value)? sharedPreferencesError,
    TResult Function(SecureStorageError<T> value)? secureStorageError,
  }) {
    return socketError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Unauthenticated<T> value)? unauthenticated,
    TResult Function(Unauthorized<T> value)? unauthorized,
    TResult Function(NoConnection<T> value)? noConnection,
    TResult Function(SocketError<T> value)? socketError,
    TResult Function(HandShakeError<T> value)? handShakeError,
    TResult Function(UnexpectedError<T> value)? unexpectedError,
    TResult Function(HiveError<T> value)? hiveError,
    TResult Function(SharedPreferencesError<T> value)? sharedPreferencesError,
    TResult Function(SecureStorageError<T> value)? secureStorageError,
    required TResult orElse(),
  }) {
    if (socketError != null) {
      return socketError(this);
    }
    return orElse();
  }
}

abstract class SocketError<T> implements FixtureFailures<T> {
  const factory SocketError({required String failedValue}) = _$SocketError<T>;

  String get failedValue;
  @JsonKey(ignore: true)
  $SocketErrorCopyWith<T, SocketError<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $HandShakeErrorCopyWith<T, $Res> {
  factory $HandShakeErrorCopyWith(
          HandShakeError<T> value, $Res Function(HandShakeError<T>) then) =
      _$HandShakeErrorCopyWithImpl<T, $Res>;
  $Res call({String failedValue});
}

/// @nodoc
class _$HandShakeErrorCopyWithImpl<T, $Res>
    extends _$FixtureFailuresCopyWithImpl<T, $Res>
    implements $HandShakeErrorCopyWith<T, $Res> {
  _$HandShakeErrorCopyWithImpl(
      HandShakeError<T> _value, $Res Function(HandShakeError<T>) _then)
      : super(_value, (v) => _then(v as HandShakeError<T>));

  @override
  HandShakeError<T> get _value => super._value as HandShakeError<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(HandShakeError<T>(
      failedValue: failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$HandShakeError<T> implements HandShakeError<T> {
  const _$HandShakeError({required this.failedValue});

  @override
  final String failedValue;

  @override
  String toString() {
    return 'FixtureFailures<$T>.handShakeError(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is HandShakeError<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  @JsonKey(ignore: true)
  @override
  $HandShakeErrorCopyWith<T, HandShakeError<T>> get copyWith =>
      _$HandShakeErrorCopyWithImpl<T, HandShakeError<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String failedValue) unauthenticated,
    required TResult Function(String failedValue) unauthorized,
    required TResult Function(String failedValue) noConnection,
    required TResult Function(String failedValue) socketError,
    required TResult Function(String failedValue) handShakeError,
    required TResult Function(String failedValue) unexpectedError,
    required TResult Function(T failedValue) hiveError,
    required TResult Function(T failedValue) sharedPreferencesError,
    required TResult Function(T failedValue) secureStorageError,
  }) {
    return handShakeError(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(String failedValue)? unauthenticated,
    TResult Function(String failedValue)? unauthorized,
    TResult Function(String failedValue)? noConnection,
    TResult Function(String failedValue)? socketError,
    TResult Function(String failedValue)? handShakeError,
    TResult Function(String failedValue)? unexpectedError,
    TResult Function(T failedValue)? hiveError,
    TResult Function(T failedValue)? sharedPreferencesError,
    TResult Function(T failedValue)? secureStorageError,
  }) {
    return handShakeError?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String failedValue)? unauthenticated,
    TResult Function(String failedValue)? unauthorized,
    TResult Function(String failedValue)? noConnection,
    TResult Function(String failedValue)? socketError,
    TResult Function(String failedValue)? handShakeError,
    TResult Function(String failedValue)? unexpectedError,
    TResult Function(T failedValue)? hiveError,
    TResult Function(T failedValue)? sharedPreferencesError,
    TResult Function(T failedValue)? secureStorageError,
    required TResult orElse(),
  }) {
    if (handShakeError != null) {
      return handShakeError(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Unauthenticated<T> value) unauthenticated,
    required TResult Function(Unauthorized<T> value) unauthorized,
    required TResult Function(NoConnection<T> value) noConnection,
    required TResult Function(SocketError<T> value) socketError,
    required TResult Function(HandShakeError<T> value) handShakeError,
    required TResult Function(UnexpectedError<T> value) unexpectedError,
    required TResult Function(HiveError<T> value) hiveError,
    required TResult Function(SharedPreferencesError<T> value)
        sharedPreferencesError,
    required TResult Function(SecureStorageError<T> value) secureStorageError,
  }) {
    return handShakeError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Unauthenticated<T> value)? unauthenticated,
    TResult Function(Unauthorized<T> value)? unauthorized,
    TResult Function(NoConnection<T> value)? noConnection,
    TResult Function(SocketError<T> value)? socketError,
    TResult Function(HandShakeError<T> value)? handShakeError,
    TResult Function(UnexpectedError<T> value)? unexpectedError,
    TResult Function(HiveError<T> value)? hiveError,
    TResult Function(SharedPreferencesError<T> value)? sharedPreferencesError,
    TResult Function(SecureStorageError<T> value)? secureStorageError,
  }) {
    return handShakeError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Unauthenticated<T> value)? unauthenticated,
    TResult Function(Unauthorized<T> value)? unauthorized,
    TResult Function(NoConnection<T> value)? noConnection,
    TResult Function(SocketError<T> value)? socketError,
    TResult Function(HandShakeError<T> value)? handShakeError,
    TResult Function(UnexpectedError<T> value)? unexpectedError,
    TResult Function(HiveError<T> value)? hiveError,
    TResult Function(SharedPreferencesError<T> value)? sharedPreferencesError,
    TResult Function(SecureStorageError<T> value)? secureStorageError,
    required TResult orElse(),
  }) {
    if (handShakeError != null) {
      return handShakeError(this);
    }
    return orElse();
  }
}

abstract class HandShakeError<T> implements FixtureFailures<T> {
  const factory HandShakeError({required String failedValue}) =
      _$HandShakeError<T>;

  String get failedValue;
  @JsonKey(ignore: true)
  $HandShakeErrorCopyWith<T, HandShakeError<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UnexpectedErrorCopyWith<T, $Res> {
  factory $UnexpectedErrorCopyWith(
          UnexpectedError<T> value, $Res Function(UnexpectedError<T>) then) =
      _$UnexpectedErrorCopyWithImpl<T, $Res>;
  $Res call({String failedValue});
}

/// @nodoc
class _$UnexpectedErrorCopyWithImpl<T, $Res>
    extends _$FixtureFailuresCopyWithImpl<T, $Res>
    implements $UnexpectedErrorCopyWith<T, $Res> {
  _$UnexpectedErrorCopyWithImpl(
      UnexpectedError<T> _value, $Res Function(UnexpectedError<T>) _then)
      : super(_value, (v) => _then(v as UnexpectedError<T>));

  @override
  UnexpectedError<T> get _value => super._value as UnexpectedError<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(UnexpectedError<T>(
      failedValue: failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$UnexpectedError<T> implements UnexpectedError<T> {
  const _$UnexpectedError({required this.failedValue});

  @override
  final String failedValue;

  @override
  String toString() {
    return 'FixtureFailures<$T>.unexpectedError(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is UnexpectedError<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  @JsonKey(ignore: true)
  @override
  $UnexpectedErrorCopyWith<T, UnexpectedError<T>> get copyWith =>
      _$UnexpectedErrorCopyWithImpl<T, UnexpectedError<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String failedValue) unauthenticated,
    required TResult Function(String failedValue) unauthorized,
    required TResult Function(String failedValue) noConnection,
    required TResult Function(String failedValue) socketError,
    required TResult Function(String failedValue) handShakeError,
    required TResult Function(String failedValue) unexpectedError,
    required TResult Function(T failedValue) hiveError,
    required TResult Function(T failedValue) sharedPreferencesError,
    required TResult Function(T failedValue) secureStorageError,
  }) {
    return unexpectedError(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(String failedValue)? unauthenticated,
    TResult Function(String failedValue)? unauthorized,
    TResult Function(String failedValue)? noConnection,
    TResult Function(String failedValue)? socketError,
    TResult Function(String failedValue)? handShakeError,
    TResult Function(String failedValue)? unexpectedError,
    TResult Function(T failedValue)? hiveError,
    TResult Function(T failedValue)? sharedPreferencesError,
    TResult Function(T failedValue)? secureStorageError,
  }) {
    return unexpectedError?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String failedValue)? unauthenticated,
    TResult Function(String failedValue)? unauthorized,
    TResult Function(String failedValue)? noConnection,
    TResult Function(String failedValue)? socketError,
    TResult Function(String failedValue)? handShakeError,
    TResult Function(String failedValue)? unexpectedError,
    TResult Function(T failedValue)? hiveError,
    TResult Function(T failedValue)? sharedPreferencesError,
    TResult Function(T failedValue)? secureStorageError,
    required TResult orElse(),
  }) {
    if (unexpectedError != null) {
      return unexpectedError(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Unauthenticated<T> value) unauthenticated,
    required TResult Function(Unauthorized<T> value) unauthorized,
    required TResult Function(NoConnection<T> value) noConnection,
    required TResult Function(SocketError<T> value) socketError,
    required TResult Function(HandShakeError<T> value) handShakeError,
    required TResult Function(UnexpectedError<T> value) unexpectedError,
    required TResult Function(HiveError<T> value) hiveError,
    required TResult Function(SharedPreferencesError<T> value)
        sharedPreferencesError,
    required TResult Function(SecureStorageError<T> value) secureStorageError,
  }) {
    return unexpectedError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Unauthenticated<T> value)? unauthenticated,
    TResult Function(Unauthorized<T> value)? unauthorized,
    TResult Function(NoConnection<T> value)? noConnection,
    TResult Function(SocketError<T> value)? socketError,
    TResult Function(HandShakeError<T> value)? handShakeError,
    TResult Function(UnexpectedError<T> value)? unexpectedError,
    TResult Function(HiveError<T> value)? hiveError,
    TResult Function(SharedPreferencesError<T> value)? sharedPreferencesError,
    TResult Function(SecureStorageError<T> value)? secureStorageError,
  }) {
    return unexpectedError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Unauthenticated<T> value)? unauthenticated,
    TResult Function(Unauthorized<T> value)? unauthorized,
    TResult Function(NoConnection<T> value)? noConnection,
    TResult Function(SocketError<T> value)? socketError,
    TResult Function(HandShakeError<T> value)? handShakeError,
    TResult Function(UnexpectedError<T> value)? unexpectedError,
    TResult Function(HiveError<T> value)? hiveError,
    TResult Function(SharedPreferencesError<T> value)? sharedPreferencesError,
    TResult Function(SecureStorageError<T> value)? secureStorageError,
    required TResult orElse(),
  }) {
    if (unexpectedError != null) {
      return unexpectedError(this);
    }
    return orElse();
  }
}

abstract class UnexpectedError<T> implements FixtureFailures<T> {
  const factory UnexpectedError({required String failedValue}) =
      _$UnexpectedError<T>;

  String get failedValue;
  @JsonKey(ignore: true)
  $UnexpectedErrorCopyWith<T, UnexpectedError<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $HiveErrorCopyWith<T, $Res> {
  factory $HiveErrorCopyWith(
          HiveError<T> value, $Res Function(HiveError<T>) then) =
      _$HiveErrorCopyWithImpl<T, $Res>;
  $Res call({T failedValue});
}

/// @nodoc
class _$HiveErrorCopyWithImpl<T, $Res>
    extends _$FixtureFailuresCopyWithImpl<T, $Res>
    implements $HiveErrorCopyWith<T, $Res> {
  _$HiveErrorCopyWithImpl(
      HiveError<T> _value, $Res Function(HiveError<T>) _then)
      : super(_value, (v) => _then(v as HiveError<T>));

  @override
  HiveError<T> get _value => super._value as HiveError<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(HiveError<T>(
      failedValue: failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$HiveError<T> implements HiveError<T> {
  const _$HiveError({required this.failedValue});

  @override
  final T failedValue;

  @override
  String toString() {
    return 'FixtureFailures<$T>.hiveError(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is HiveError<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  @JsonKey(ignore: true)
  @override
  $HiveErrorCopyWith<T, HiveError<T>> get copyWith =>
      _$HiveErrorCopyWithImpl<T, HiveError<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String failedValue) unauthenticated,
    required TResult Function(String failedValue) unauthorized,
    required TResult Function(String failedValue) noConnection,
    required TResult Function(String failedValue) socketError,
    required TResult Function(String failedValue) handShakeError,
    required TResult Function(String failedValue) unexpectedError,
    required TResult Function(T failedValue) hiveError,
    required TResult Function(T failedValue) sharedPreferencesError,
    required TResult Function(T failedValue) secureStorageError,
  }) {
    return hiveError(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(String failedValue)? unauthenticated,
    TResult Function(String failedValue)? unauthorized,
    TResult Function(String failedValue)? noConnection,
    TResult Function(String failedValue)? socketError,
    TResult Function(String failedValue)? handShakeError,
    TResult Function(String failedValue)? unexpectedError,
    TResult Function(T failedValue)? hiveError,
    TResult Function(T failedValue)? sharedPreferencesError,
    TResult Function(T failedValue)? secureStorageError,
  }) {
    return hiveError?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String failedValue)? unauthenticated,
    TResult Function(String failedValue)? unauthorized,
    TResult Function(String failedValue)? noConnection,
    TResult Function(String failedValue)? socketError,
    TResult Function(String failedValue)? handShakeError,
    TResult Function(String failedValue)? unexpectedError,
    TResult Function(T failedValue)? hiveError,
    TResult Function(T failedValue)? sharedPreferencesError,
    TResult Function(T failedValue)? secureStorageError,
    required TResult orElse(),
  }) {
    if (hiveError != null) {
      return hiveError(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Unauthenticated<T> value) unauthenticated,
    required TResult Function(Unauthorized<T> value) unauthorized,
    required TResult Function(NoConnection<T> value) noConnection,
    required TResult Function(SocketError<T> value) socketError,
    required TResult Function(HandShakeError<T> value) handShakeError,
    required TResult Function(UnexpectedError<T> value) unexpectedError,
    required TResult Function(HiveError<T> value) hiveError,
    required TResult Function(SharedPreferencesError<T> value)
        sharedPreferencesError,
    required TResult Function(SecureStorageError<T> value) secureStorageError,
  }) {
    return hiveError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Unauthenticated<T> value)? unauthenticated,
    TResult Function(Unauthorized<T> value)? unauthorized,
    TResult Function(NoConnection<T> value)? noConnection,
    TResult Function(SocketError<T> value)? socketError,
    TResult Function(HandShakeError<T> value)? handShakeError,
    TResult Function(UnexpectedError<T> value)? unexpectedError,
    TResult Function(HiveError<T> value)? hiveError,
    TResult Function(SharedPreferencesError<T> value)? sharedPreferencesError,
    TResult Function(SecureStorageError<T> value)? secureStorageError,
  }) {
    return hiveError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Unauthenticated<T> value)? unauthenticated,
    TResult Function(Unauthorized<T> value)? unauthorized,
    TResult Function(NoConnection<T> value)? noConnection,
    TResult Function(SocketError<T> value)? socketError,
    TResult Function(HandShakeError<T> value)? handShakeError,
    TResult Function(UnexpectedError<T> value)? unexpectedError,
    TResult Function(HiveError<T> value)? hiveError,
    TResult Function(SharedPreferencesError<T> value)? sharedPreferencesError,
    TResult Function(SecureStorageError<T> value)? secureStorageError,
    required TResult orElse(),
  }) {
    if (hiveError != null) {
      return hiveError(this);
    }
    return orElse();
  }
}

abstract class HiveError<T> implements FixtureFailures<T> {
  const factory HiveError({required T failedValue}) = _$HiveError<T>;

  T get failedValue;
  @JsonKey(ignore: true)
  $HiveErrorCopyWith<T, HiveError<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SharedPreferencesErrorCopyWith<T, $Res> {
  factory $SharedPreferencesErrorCopyWith(SharedPreferencesError<T> value,
          $Res Function(SharedPreferencesError<T>) then) =
      _$SharedPreferencesErrorCopyWithImpl<T, $Res>;
  $Res call({T failedValue});
}

/// @nodoc
class _$SharedPreferencesErrorCopyWithImpl<T, $Res>
    extends _$FixtureFailuresCopyWithImpl<T, $Res>
    implements $SharedPreferencesErrorCopyWith<T, $Res> {
  _$SharedPreferencesErrorCopyWithImpl(SharedPreferencesError<T> _value,
      $Res Function(SharedPreferencesError<T>) _then)
      : super(_value, (v) => _then(v as SharedPreferencesError<T>));

  @override
  SharedPreferencesError<T> get _value =>
      super._value as SharedPreferencesError<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(SharedPreferencesError<T>(
      failedValue: failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$SharedPreferencesError<T> implements SharedPreferencesError<T> {
  const _$SharedPreferencesError({required this.failedValue});

  @override
  final T failedValue;

  @override
  String toString() {
    return 'FixtureFailures<$T>.sharedPreferencesError(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is SharedPreferencesError<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  @JsonKey(ignore: true)
  @override
  $SharedPreferencesErrorCopyWith<T, SharedPreferencesError<T>> get copyWith =>
      _$SharedPreferencesErrorCopyWithImpl<T, SharedPreferencesError<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String failedValue) unauthenticated,
    required TResult Function(String failedValue) unauthorized,
    required TResult Function(String failedValue) noConnection,
    required TResult Function(String failedValue) socketError,
    required TResult Function(String failedValue) handShakeError,
    required TResult Function(String failedValue) unexpectedError,
    required TResult Function(T failedValue) hiveError,
    required TResult Function(T failedValue) sharedPreferencesError,
    required TResult Function(T failedValue) secureStorageError,
  }) {
    return sharedPreferencesError(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(String failedValue)? unauthenticated,
    TResult Function(String failedValue)? unauthorized,
    TResult Function(String failedValue)? noConnection,
    TResult Function(String failedValue)? socketError,
    TResult Function(String failedValue)? handShakeError,
    TResult Function(String failedValue)? unexpectedError,
    TResult Function(T failedValue)? hiveError,
    TResult Function(T failedValue)? sharedPreferencesError,
    TResult Function(T failedValue)? secureStorageError,
  }) {
    return sharedPreferencesError?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String failedValue)? unauthenticated,
    TResult Function(String failedValue)? unauthorized,
    TResult Function(String failedValue)? noConnection,
    TResult Function(String failedValue)? socketError,
    TResult Function(String failedValue)? handShakeError,
    TResult Function(String failedValue)? unexpectedError,
    TResult Function(T failedValue)? hiveError,
    TResult Function(T failedValue)? sharedPreferencesError,
    TResult Function(T failedValue)? secureStorageError,
    required TResult orElse(),
  }) {
    if (sharedPreferencesError != null) {
      return sharedPreferencesError(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Unauthenticated<T> value) unauthenticated,
    required TResult Function(Unauthorized<T> value) unauthorized,
    required TResult Function(NoConnection<T> value) noConnection,
    required TResult Function(SocketError<T> value) socketError,
    required TResult Function(HandShakeError<T> value) handShakeError,
    required TResult Function(UnexpectedError<T> value) unexpectedError,
    required TResult Function(HiveError<T> value) hiveError,
    required TResult Function(SharedPreferencesError<T> value)
        sharedPreferencesError,
    required TResult Function(SecureStorageError<T> value) secureStorageError,
  }) {
    return sharedPreferencesError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Unauthenticated<T> value)? unauthenticated,
    TResult Function(Unauthorized<T> value)? unauthorized,
    TResult Function(NoConnection<T> value)? noConnection,
    TResult Function(SocketError<T> value)? socketError,
    TResult Function(HandShakeError<T> value)? handShakeError,
    TResult Function(UnexpectedError<T> value)? unexpectedError,
    TResult Function(HiveError<T> value)? hiveError,
    TResult Function(SharedPreferencesError<T> value)? sharedPreferencesError,
    TResult Function(SecureStorageError<T> value)? secureStorageError,
  }) {
    return sharedPreferencesError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Unauthenticated<T> value)? unauthenticated,
    TResult Function(Unauthorized<T> value)? unauthorized,
    TResult Function(NoConnection<T> value)? noConnection,
    TResult Function(SocketError<T> value)? socketError,
    TResult Function(HandShakeError<T> value)? handShakeError,
    TResult Function(UnexpectedError<T> value)? unexpectedError,
    TResult Function(HiveError<T> value)? hiveError,
    TResult Function(SharedPreferencesError<T> value)? sharedPreferencesError,
    TResult Function(SecureStorageError<T> value)? secureStorageError,
    required TResult orElse(),
  }) {
    if (sharedPreferencesError != null) {
      return sharedPreferencesError(this);
    }
    return orElse();
  }
}

abstract class SharedPreferencesError<T> implements FixtureFailures<T> {
  const factory SharedPreferencesError({required T failedValue}) =
      _$SharedPreferencesError<T>;

  T get failedValue;
  @JsonKey(ignore: true)
  $SharedPreferencesErrorCopyWith<T, SharedPreferencesError<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SecureStorageErrorCopyWith<T, $Res> {
  factory $SecureStorageErrorCopyWith(SecureStorageError<T> value,
          $Res Function(SecureStorageError<T>) then) =
      _$SecureStorageErrorCopyWithImpl<T, $Res>;
  $Res call({T failedValue});
}

/// @nodoc
class _$SecureStorageErrorCopyWithImpl<T, $Res>
    extends _$FixtureFailuresCopyWithImpl<T, $Res>
    implements $SecureStorageErrorCopyWith<T, $Res> {
  _$SecureStorageErrorCopyWithImpl(
      SecureStorageError<T> _value, $Res Function(SecureStorageError<T>) _then)
      : super(_value, (v) => _then(v as SecureStorageError<T>));

  @override
  SecureStorageError<T> get _value => super._value as SecureStorageError<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(SecureStorageError<T>(
      failedValue: failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$SecureStorageError<T> implements SecureStorageError<T> {
  const _$SecureStorageError({required this.failedValue});

  @override
  final T failedValue;

  @override
  String toString() {
    return 'FixtureFailures<$T>.secureStorageError(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is SecureStorageError<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  @JsonKey(ignore: true)
  @override
  $SecureStorageErrorCopyWith<T, SecureStorageError<T>> get copyWith =>
      _$SecureStorageErrorCopyWithImpl<T, SecureStorageError<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String failedValue) unauthenticated,
    required TResult Function(String failedValue) unauthorized,
    required TResult Function(String failedValue) noConnection,
    required TResult Function(String failedValue) socketError,
    required TResult Function(String failedValue) handShakeError,
    required TResult Function(String failedValue) unexpectedError,
    required TResult Function(T failedValue) hiveError,
    required TResult Function(T failedValue) sharedPreferencesError,
    required TResult Function(T failedValue) secureStorageError,
  }) {
    return secureStorageError(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(String failedValue)? unauthenticated,
    TResult Function(String failedValue)? unauthorized,
    TResult Function(String failedValue)? noConnection,
    TResult Function(String failedValue)? socketError,
    TResult Function(String failedValue)? handShakeError,
    TResult Function(String failedValue)? unexpectedError,
    TResult Function(T failedValue)? hiveError,
    TResult Function(T failedValue)? sharedPreferencesError,
    TResult Function(T failedValue)? secureStorageError,
  }) {
    return secureStorageError?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String failedValue)? unauthenticated,
    TResult Function(String failedValue)? unauthorized,
    TResult Function(String failedValue)? noConnection,
    TResult Function(String failedValue)? socketError,
    TResult Function(String failedValue)? handShakeError,
    TResult Function(String failedValue)? unexpectedError,
    TResult Function(T failedValue)? hiveError,
    TResult Function(T failedValue)? sharedPreferencesError,
    TResult Function(T failedValue)? secureStorageError,
    required TResult orElse(),
  }) {
    if (secureStorageError != null) {
      return secureStorageError(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Unauthenticated<T> value) unauthenticated,
    required TResult Function(Unauthorized<T> value) unauthorized,
    required TResult Function(NoConnection<T> value) noConnection,
    required TResult Function(SocketError<T> value) socketError,
    required TResult Function(HandShakeError<T> value) handShakeError,
    required TResult Function(UnexpectedError<T> value) unexpectedError,
    required TResult Function(HiveError<T> value) hiveError,
    required TResult Function(SharedPreferencesError<T> value)
        sharedPreferencesError,
    required TResult Function(SecureStorageError<T> value) secureStorageError,
  }) {
    return secureStorageError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Unauthenticated<T> value)? unauthenticated,
    TResult Function(Unauthorized<T> value)? unauthorized,
    TResult Function(NoConnection<T> value)? noConnection,
    TResult Function(SocketError<T> value)? socketError,
    TResult Function(HandShakeError<T> value)? handShakeError,
    TResult Function(UnexpectedError<T> value)? unexpectedError,
    TResult Function(HiveError<T> value)? hiveError,
    TResult Function(SharedPreferencesError<T> value)? sharedPreferencesError,
    TResult Function(SecureStorageError<T> value)? secureStorageError,
  }) {
    return secureStorageError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Unauthenticated<T> value)? unauthenticated,
    TResult Function(Unauthorized<T> value)? unauthorized,
    TResult Function(NoConnection<T> value)? noConnection,
    TResult Function(SocketError<T> value)? socketError,
    TResult Function(HandShakeError<T> value)? handShakeError,
    TResult Function(UnexpectedError<T> value)? unexpectedError,
    TResult Function(HiveError<T> value)? hiveError,
    TResult Function(SharedPreferencesError<T> value)? sharedPreferencesError,
    TResult Function(SecureStorageError<T> value)? secureStorageError,
    required TResult orElse(),
  }) {
    if (secureStorageError != null) {
      return secureStorageError(this);
    }
    return orElse();
  }
}

abstract class SecureStorageError<T> implements FixtureFailures<T> {
  const factory SecureStorageError({required T failedValue}) =
      _$SecureStorageError<T>;

  T get failedValue;
  @JsonKey(ignore: true)
  $SecureStorageErrorCopyWith<T, SecureStorageError<T>> get copyWith =>
      throw _privateConstructorUsedError;
}
