// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'util_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$UtilEventTearOff {
  const _$UtilEventTearOff();

  _SetDefaultLocale setDefaultLocale() {
    return const _SetDefaultLocale();
  }

  _SetLocale setLocale({required Locale newLocale}) {
    return _SetLocale(
      newLocale: newLocale,
    );
  }

  _ClearLocale clearLocale({required Locale newLocale}) {
    return _ClearLocale(
      newLocale: newLocale,
    );
  }
}

/// @nodoc
const $UtilEvent = _$UtilEventTearOff();

/// @nodoc
mixin _$UtilEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() setDefaultLocale,
    required TResult Function(Locale newLocale) setLocale,
    required TResult Function(Locale newLocale) clearLocale,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? setDefaultLocale,
    TResult Function(Locale newLocale)? setLocale,
    TResult Function(Locale newLocale)? clearLocale,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? setDefaultLocale,
    TResult Function(Locale newLocale)? setLocale,
    TResult Function(Locale newLocale)? clearLocale,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_SetDefaultLocale value) setDefaultLocale,
    required TResult Function(_SetLocale value) setLocale,
    required TResult Function(_ClearLocale value) clearLocale,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_SetDefaultLocale value)? setDefaultLocale,
    TResult Function(_SetLocale value)? setLocale,
    TResult Function(_ClearLocale value)? clearLocale,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_SetDefaultLocale value)? setDefaultLocale,
    TResult Function(_SetLocale value)? setLocale,
    TResult Function(_ClearLocale value)? clearLocale,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UtilEventCopyWith<$Res> {
  factory $UtilEventCopyWith(UtilEvent value, $Res Function(UtilEvent) then) =
      _$UtilEventCopyWithImpl<$Res>;
}

/// @nodoc
class _$UtilEventCopyWithImpl<$Res> implements $UtilEventCopyWith<$Res> {
  _$UtilEventCopyWithImpl(this._value, this._then);

  final UtilEvent _value;
  // ignore: unused_field
  final $Res Function(UtilEvent) _then;
}

/// @nodoc
abstract class _$SetDefaultLocaleCopyWith<$Res> {
  factory _$SetDefaultLocaleCopyWith(
          _SetDefaultLocale value, $Res Function(_SetDefaultLocale) then) =
      __$SetDefaultLocaleCopyWithImpl<$Res>;
}

/// @nodoc
class __$SetDefaultLocaleCopyWithImpl<$Res>
    extends _$UtilEventCopyWithImpl<$Res>
    implements _$SetDefaultLocaleCopyWith<$Res> {
  __$SetDefaultLocaleCopyWithImpl(
      _SetDefaultLocale _value, $Res Function(_SetDefaultLocale) _then)
      : super(_value, (v) => _then(v as _SetDefaultLocale));

  @override
  _SetDefaultLocale get _value => super._value as _SetDefaultLocale;
}

/// @nodoc

class _$_SetDefaultLocale implements _SetDefaultLocale {
  const _$_SetDefaultLocale();

  @override
  String toString() {
    return 'UtilEvent.setDefaultLocale()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _SetDefaultLocale);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() setDefaultLocale,
    required TResult Function(Locale newLocale) setLocale,
    required TResult Function(Locale newLocale) clearLocale,
  }) {
    return setDefaultLocale();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? setDefaultLocale,
    TResult Function(Locale newLocale)? setLocale,
    TResult Function(Locale newLocale)? clearLocale,
  }) {
    return setDefaultLocale?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? setDefaultLocale,
    TResult Function(Locale newLocale)? setLocale,
    TResult Function(Locale newLocale)? clearLocale,
    required TResult orElse(),
  }) {
    if (setDefaultLocale != null) {
      return setDefaultLocale();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_SetDefaultLocale value) setDefaultLocale,
    required TResult Function(_SetLocale value) setLocale,
    required TResult Function(_ClearLocale value) clearLocale,
  }) {
    return setDefaultLocale(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_SetDefaultLocale value)? setDefaultLocale,
    TResult Function(_SetLocale value)? setLocale,
    TResult Function(_ClearLocale value)? clearLocale,
  }) {
    return setDefaultLocale?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_SetDefaultLocale value)? setDefaultLocale,
    TResult Function(_SetLocale value)? setLocale,
    TResult Function(_ClearLocale value)? clearLocale,
    required TResult orElse(),
  }) {
    if (setDefaultLocale != null) {
      return setDefaultLocale(this);
    }
    return orElse();
  }
}

abstract class _SetDefaultLocale implements UtilEvent {
  const factory _SetDefaultLocale() = _$_SetDefaultLocale;
}

/// @nodoc
abstract class _$SetLocaleCopyWith<$Res> {
  factory _$SetLocaleCopyWith(
          _SetLocale value, $Res Function(_SetLocale) then) =
      __$SetLocaleCopyWithImpl<$Res>;
  $Res call({Locale newLocale});
}

/// @nodoc
class __$SetLocaleCopyWithImpl<$Res> extends _$UtilEventCopyWithImpl<$Res>
    implements _$SetLocaleCopyWith<$Res> {
  __$SetLocaleCopyWithImpl(_SetLocale _value, $Res Function(_SetLocale) _then)
      : super(_value, (v) => _then(v as _SetLocale));

  @override
  _SetLocale get _value => super._value as _SetLocale;

  @override
  $Res call({
    Object? newLocale = freezed,
  }) {
    return _then(_SetLocale(
      newLocale: newLocale == freezed
          ? _value.newLocale
          : newLocale // ignore: cast_nullable_to_non_nullable
              as Locale,
    ));
  }
}

/// @nodoc

class _$_SetLocale implements _SetLocale {
  const _$_SetLocale({required this.newLocale});

  @override
  final Locale newLocale;

  @override
  String toString() {
    return 'UtilEvent.setLocale(newLocale: $newLocale)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _SetLocale &&
            const DeepCollectionEquality().equals(other.newLocale, newLocale));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(newLocale));

  @JsonKey(ignore: true)
  @override
  _$SetLocaleCopyWith<_SetLocale> get copyWith =>
      __$SetLocaleCopyWithImpl<_SetLocale>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() setDefaultLocale,
    required TResult Function(Locale newLocale) setLocale,
    required TResult Function(Locale newLocale) clearLocale,
  }) {
    return setLocale(newLocale);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? setDefaultLocale,
    TResult Function(Locale newLocale)? setLocale,
    TResult Function(Locale newLocale)? clearLocale,
  }) {
    return setLocale?.call(newLocale);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? setDefaultLocale,
    TResult Function(Locale newLocale)? setLocale,
    TResult Function(Locale newLocale)? clearLocale,
    required TResult orElse(),
  }) {
    if (setLocale != null) {
      return setLocale(newLocale);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_SetDefaultLocale value) setDefaultLocale,
    required TResult Function(_SetLocale value) setLocale,
    required TResult Function(_ClearLocale value) clearLocale,
  }) {
    return setLocale(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_SetDefaultLocale value)? setDefaultLocale,
    TResult Function(_SetLocale value)? setLocale,
    TResult Function(_ClearLocale value)? clearLocale,
  }) {
    return setLocale?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_SetDefaultLocale value)? setDefaultLocale,
    TResult Function(_SetLocale value)? setLocale,
    TResult Function(_ClearLocale value)? clearLocale,
    required TResult orElse(),
  }) {
    if (setLocale != null) {
      return setLocale(this);
    }
    return orElse();
  }
}

abstract class _SetLocale implements UtilEvent {
  const factory _SetLocale({required Locale newLocale}) = _$_SetLocale;

  Locale get newLocale;
  @JsonKey(ignore: true)
  _$SetLocaleCopyWith<_SetLocale> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$ClearLocaleCopyWith<$Res> {
  factory _$ClearLocaleCopyWith(
          _ClearLocale value, $Res Function(_ClearLocale) then) =
      __$ClearLocaleCopyWithImpl<$Res>;
  $Res call({Locale newLocale});
}

/// @nodoc
class __$ClearLocaleCopyWithImpl<$Res> extends _$UtilEventCopyWithImpl<$Res>
    implements _$ClearLocaleCopyWith<$Res> {
  __$ClearLocaleCopyWithImpl(
      _ClearLocale _value, $Res Function(_ClearLocale) _then)
      : super(_value, (v) => _then(v as _ClearLocale));

  @override
  _ClearLocale get _value => super._value as _ClearLocale;

  @override
  $Res call({
    Object? newLocale = freezed,
  }) {
    return _then(_ClearLocale(
      newLocale: newLocale == freezed
          ? _value.newLocale
          : newLocale // ignore: cast_nullable_to_non_nullable
              as Locale,
    ));
  }
}

/// @nodoc

class _$_ClearLocale implements _ClearLocale {
  const _$_ClearLocale({required this.newLocale});

  @override
  final Locale newLocale;

  @override
  String toString() {
    return 'UtilEvent.clearLocale(newLocale: $newLocale)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ClearLocale &&
            const DeepCollectionEquality().equals(other.newLocale, newLocale));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(newLocale));

  @JsonKey(ignore: true)
  @override
  _$ClearLocaleCopyWith<_ClearLocale> get copyWith =>
      __$ClearLocaleCopyWithImpl<_ClearLocale>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() setDefaultLocale,
    required TResult Function(Locale newLocale) setLocale,
    required TResult Function(Locale newLocale) clearLocale,
  }) {
    return clearLocale(newLocale);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? setDefaultLocale,
    TResult Function(Locale newLocale)? setLocale,
    TResult Function(Locale newLocale)? clearLocale,
  }) {
    return clearLocale?.call(newLocale);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? setDefaultLocale,
    TResult Function(Locale newLocale)? setLocale,
    TResult Function(Locale newLocale)? clearLocale,
    required TResult orElse(),
  }) {
    if (clearLocale != null) {
      return clearLocale(newLocale);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_SetDefaultLocale value) setDefaultLocale,
    required TResult Function(_SetLocale value) setLocale,
    required TResult Function(_ClearLocale value) clearLocale,
  }) {
    return clearLocale(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_SetDefaultLocale value)? setDefaultLocale,
    TResult Function(_SetLocale value)? setLocale,
    TResult Function(_ClearLocale value)? clearLocale,
  }) {
    return clearLocale?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_SetDefaultLocale value)? setDefaultLocale,
    TResult Function(_SetLocale value)? setLocale,
    TResult Function(_ClearLocale value)? clearLocale,
    required TResult orElse(),
  }) {
    if (clearLocale != null) {
      return clearLocale(this);
    }
    return orElse();
  }
}

abstract class _ClearLocale implements UtilEvent {
  const factory _ClearLocale({required Locale newLocale}) = _$_ClearLocale;

  Locale get newLocale;
  @JsonKey(ignore: true)
  _$ClearLocaleCopyWith<_ClearLocale> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
class _$UtilStateTearOff {
  const _$UtilStateTearOff();

  _UtilState call({required Locale locale}) {
    return _UtilState(
      locale: locale,
    );
  }
}

/// @nodoc
const $UtilState = _$UtilStateTearOff();

/// @nodoc
mixin _$UtilState {
  Locale get locale => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $UtilStateCopyWith<UtilState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UtilStateCopyWith<$Res> {
  factory $UtilStateCopyWith(UtilState value, $Res Function(UtilState) then) =
      _$UtilStateCopyWithImpl<$Res>;
  $Res call({Locale locale});
}

/// @nodoc
class _$UtilStateCopyWithImpl<$Res> implements $UtilStateCopyWith<$Res> {
  _$UtilStateCopyWithImpl(this._value, this._then);

  final UtilState _value;
  // ignore: unused_field
  final $Res Function(UtilState) _then;

  @override
  $Res call({
    Object? locale = freezed,
  }) {
    return _then(_value.copyWith(
      locale: locale == freezed
          ? _value.locale
          : locale // ignore: cast_nullable_to_non_nullable
              as Locale,
    ));
  }
}

/// @nodoc
abstract class _$UtilStateCopyWith<$Res> implements $UtilStateCopyWith<$Res> {
  factory _$UtilStateCopyWith(
          _UtilState value, $Res Function(_UtilState) then) =
      __$UtilStateCopyWithImpl<$Res>;
  @override
  $Res call({Locale locale});
}

/// @nodoc
class __$UtilStateCopyWithImpl<$Res> extends _$UtilStateCopyWithImpl<$Res>
    implements _$UtilStateCopyWith<$Res> {
  __$UtilStateCopyWithImpl(_UtilState _value, $Res Function(_UtilState) _then)
      : super(_value, (v) => _then(v as _UtilState));

  @override
  _UtilState get _value => super._value as _UtilState;

  @override
  $Res call({
    Object? locale = freezed,
  }) {
    return _then(_UtilState(
      locale: locale == freezed
          ? _value.locale
          : locale // ignore: cast_nullable_to_non_nullable
              as Locale,
    ));
  }
}

/// @nodoc

class _$_UtilState implements _UtilState {
  const _$_UtilState({required this.locale});

  @override
  final Locale locale;

  @override
  String toString() {
    return 'UtilState(locale: $locale)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _UtilState &&
            const DeepCollectionEquality().equals(other.locale, locale));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(locale));

  @JsonKey(ignore: true)
  @override
  _$UtilStateCopyWith<_UtilState> get copyWith =>
      __$UtilStateCopyWithImpl<_UtilState>(this, _$identity);
}

abstract class _UtilState implements UtilState {
  const factory _UtilState({required Locale locale}) = _$_UtilState;

  @override
  Locale get locale;
  @override
  @JsonKey(ignore: true)
  _$UtilStateCopyWith<_UtilState> get copyWith =>
      throw _privateConstructorUsedError;
}
